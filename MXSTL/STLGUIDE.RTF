{\rtf1\ansi \deff8\deflang1033{\fonttbl{\f0\froman\fcharset0\fprq2 Tms Rmn;}{\f1\froman\fcharset2\fprq2 Symbol;}{\f2\fswiss\fcharset0\fprq2 Helv;}{\f3\fmodern\fcharset0\fprq1 Courier;}
{\f4\froman\fcharset0\fprq2 Times New Roman;}{\f5\fswiss\fcharset0\fprq2 Arial;}{\f6\froman\fcharset0\fprq2 MS Serif;}{\f7\fswiss\fcharset0\fprq2 MS Sans Serif;}{\f8\froman\fcharset0\fprq2 Times;}{\f9\fswiss\fcharset0\fprq2 Helvetica;}
{\f10\fswiss\fcharset0\fprq2 System;}{\f11\fmodern\fcharset0\fprq1 Courier New;}{\f12\froman\fcharset0\fprq2 New York;}{\f13\fswiss\fcharset0\fprq2 Geneva;}{\f14\fswiss\fcharset0\fprq2 AvantGarde;}{\f15\froman\fcharset0\fprq2 ITC Bookman;}
{\f16\fswiss\fcharset0\fprq2 Helvetica-Narrow;}{\f17\froman\fcharset0\fprq2 NewCenturySchlbk;}{\f18\froman\fcharset0\fprq2 Palatino;}{\f19\froman\fcharset0\fprq2 ZapfChancery;}{\f20\fdecor\fcharset2\fprq2 ZapfDingbats;}
{\f21\fmodern\fcharset0\fprq1 Lucida Console;}{\f22\fnil\fcharset2\fprq2 Wingdings;}{\f23\froman\fcharset2\fprq2 MT Extra;}{\f24\fmodern\fcharset2\fprq1 MS LineDraw;}{\f25\fdecor\fcharset0\fprq2 Algerian;}
{\f26\fswiss\fcharset0\fprq2 Arial Rounded MT Bold;}{\f27\fdecor\fcharset0\fprq2 Bauhaus 93;}{\f28\froman\fcharset0\fprq2 Bookman Old Style;}{\f29\fdecor\fcharset0\fprq2 Braggadocio;}{\f30\fswiss\fcharset0\fprq2 Britannic Bold;}
{\f31\fscript\fcharset0\fprq2 Brush Script MT;}{\f32\fdecor\fcharset0\fprq2 Colonna MT;}{\f33\fdecor\fcharset0\fprq2 Desdemona;}{\f34\froman\fcharset0\fprq2 Footlight MT Light;}{\f35\fswiss\fcharset0\fprq2 Century Gothic;}
{\f36\fscript\fcharset0\fprq2 Gradl;}{\f37\fswiss\fcharset0\fprq2 Impact;}{\f38\fdecor\fcharset0\fprq2 Kino MT;}{\f39\froman\fcharset0\fprq2 Wide Latin;}{\f40\fscript\fcharset0\fprq2 Matura MT Script Capitals;}{\f41\fscript\fcharset0\fprq2 Mistral;}
{\f42\fdecor\fcharset0\fprq2 Playbill;}{\f43\fdecor\fcharset0\fprq2 Stencil;}{\f44\fscript\fcharset0\fprq2 Vivaldi;}{\f45\froman\fcharset255\fprq2 Roman;}{\f46\fscript\fcharset255\fprq2 Script;}{\f47\fmodern\fcharset255\fprq2 Modern;}
{\f48\fswiss\fcharset0\fprq1 MS Dialog;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;
\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\nowidctlpar \f8 \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}{
\s15\sl260\slmult0\nowidctlpar \f8 \sbasedon0\snext15 Abstract;}{\s16\qc\nowidctlpar \f8 \sbasedon0\snext16 Author;}{\s17\qj\nowidctlpar \f8 \sbasedon0\snext17 body;}{\s18\fi-173\li1080\sl260\slmult0\nowidctlpar\tx1080\tx1253 \f8 \sbasedon0\snext18 
bullet1;}{\s19\fi-230\li850\sl260\slmult0\nowidctlpar\tx850 \f8 \sbasedon0\snext19 bullet2;}{\s20\qc\nowidctlpar \f8 \sbasedon0\snext20 cbody;}{\s21\nowidctlpar \f8 \sbasedon0\snext21 CellBody;}{\s22\nowidctlpar \f8 \sbasedon0\snext22 Date;}{
\s23\qj\nowidctlpar \f8 \sbasedon0\snext23 ebody;}{\s24\qj\li1080\nowidctlpar \f8 \sbasedon0\snext24 Footnote;}{\s25\fi-230\li1210\sl260\slmult0\nowidctlpar\tx1210\tqr\tx1253\tx1440 \f8 \sbasedon0\snext25 footnote;}{\s26\qc\nowidctlpar \f8 
\sbasedon0\snext26 heading;}{\s27\li1080\sl260\slmult0\nowidctlpar\tx1080\tx1167 \f8 \sbasedon0\snext27 indent1;}{\s28\li850\sl260\slmult0\nowidctlpar\tx850 \f8 \sbasedon0\snext28 indent2;}{\s29\fi-360\li1080\sl260\slmult0
\nowidctlpar\tx1080\tqr\tx1138\tx1440 \f8 \sbasedon0\snext29 number1;}{\s30\fi-230\li1210\sl260\slmult0\nowidctlpar \f8 \sbasedon0\snext30 number1Start;}{\s31\nowidctlpar \f8 \sbasedon0\snext31 Organization;}{
\s32\fi-1440\li720\nowidctlpar\tx0\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \f8 \sbasedon0\snext32 program;}{\s33\fi-230\li1210\sl260\slmult0\nowidctlpar\tx1210\tx1440 \f8 \sbasedon0\snext33 reference;}{\s34\nowidctlpar\tx1167 
\f8 \sbasedon0\snext34 section;}{\s35\qj\fi-532\li908\nowidctlpar\tx908\tqr\tldot\tx7920 \f8 \sbasedon0\snext35 sectionTOC;}{\s36\sl260\slmult0\nowidctlpar \f8 \sbasedon0\snext36 subheading;}{\s37\sl260\slmult0\nowidctlpar \f8 \sbasedon0\snext37 
subsection;}{\s38\qj\fi-548\li360\nowidctlpar\tx360\tqr\tldot\tx7920 \f8 \sbasedon0\snext38 subsectionTOC;}{\s39\sl260\slmult0\nowidctlpar \f8 \sbasedon0\snext39 subsubheading;}{\s40\sl260\slmult0\nowidctlpar \f8 \sbasedon0\snext40 subsubsection;}{
\s41\qj\fi-532\li172\nowidctlpar\tx172\tqr\tldot\tx7920 \f8 \sbasedon0\snext41 subsubsectionTOC;}{\s42\qc\sl240\slmult0\nowidctlpar\tqr\tx10080 \f8 \sbasedon0\snext42 Title;}{\s43\sl240\slmult0\nowidctlpar\tqr\tx10080 \f8 \sbasedon0\snext43 TRnumber;}{
\s44\nowidctlpar\tqc\tx4320\tqr\tx8640 \f8 \sbasedon0\snext44 footer;}{\*\cs45 \additive\sbasedon10 page number;}{\s46\sb120\sa120\nowidctlpar\tqr\tldot\tx8812 \b\caps\f4\fs20 \sbasedon0\snext0 toc 1;}{\s47\nowidctlpar\tqr\tldot\tx8812 \scaps\f4\fs20 
\sbasedon0\snext0 toc 2;}{\s48\li240\nowidctlpar\tqr\tldot\tx8812 \i\f4\fs20 \sbasedon0\snext0 toc 3;}{\s49\li480\nowidctlpar\tqr\tldot\tx8812 \f4\fs18 \sbasedon0\snext0 toc 4;}{\s50\li720\nowidctlpar\tqr\tldot\tx8812 \f4\fs18 \sbasedon0\snext0 toc 5;}{
\s51\li960\nowidctlpar\tqr\tldot\tx8812 \f4\fs18 \sbasedon0\snext0 toc 6;}{\s52\li1200\nowidctlpar\tqr\tldot\tx8812 \f4\fs18 \sbasedon0\snext0 toc 7;}{\s53\li1440\nowidctlpar\tqr\tldot\tx8812 \f4\fs18 \sbasedon0\snext0 toc 8;}{
\s54\li1680\nowidctlpar\tqr\tldot\tx8812 \f4\fs18 \sbasedon0\snext0 toc 9;}}{\*\revtbl {Unknown;}}{\info{\title The Standard Template Library}{\author Kerry Loynd}{\operator Kerry Loynd}{\creatim\yr1995\mo7\dy13\hr16\min3}{\revtim\yr1995\mo7\dy13\hr16\min48}{\version5}
{\edmins38}{\nofpages0}{\nofwords0}{\nofchars0}{\vern49221}}\margl1440\margr1988 \widowctrl\ftnbj\aenddoc\hyphcaps0 \fet0\sectd \sbknone\pgnrestart\linex0 {\footer \pard\plain \s44\nowidctlpar\tqc\tx4320\tqr\tx8640\pvpara\phmrg\posxr\posy0 \f8 
{\field{\*\fldinst {\cs45 PAGE  }}{\fldrslt {\cs45 81}}}{\cs45 
\par }\pard \s44\ri360\nowidctlpar\tqc\tx4320\tqr\tx8640 
\par }{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5
\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang
{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s42\qc\ri-548\sb140\nowidctlpar \f8 {\b\f9\fs36\cf1 The Standard Template Library
\par }\pard \s42\qc\ri-548\sb140\nowidctlpar {\b\f9\fs36\cf1 
\par }\pard\plain \s16\qc\ri-548\sb200\sl280\slmult0\nowidctlpar \f8 {\i\fs28\cf1 Alexander Stepanov}{\b\fs28\cf1 
\par }\pard \s16\qc\ri-548\sb200\sl280\slmult0\nowidctlpar {\b\fs28\cf1 
\par }\pard\plain \s43\qc\ri-548\sb20\nowidctlpar \f8 {\i\cf1 Silicon Graphics Inc.}{\b\cf1 
\par }\pard \s43\qc\ri-548\sb20\nowidctlpar {\i\cf1 2011 N. Shoreline Blvd.}{\b\cf1 
\par }{\i\cf1 Mt. View, CA 94043}{\b\cf1 
\par }{\i\cf1 stepanov@mti.sgi.com}{\b\cf1 
\par }\pard \s43\qc\ri-548\sb20\nowidctlpar {\b\cf1 
\par }\pard\plain \s16\qc\ri-548\sb200\sl280\slmult0\nowidctlpar \f8 {\i\fs28\cf1 Meng Lee}{\b\fs28\cf1 
\par }\pard \s16\qc\ri-548\sb200\sl280\slmult0\nowidctlpar {\b\fs28\cf1 
\par }\pard\plain \s43\qc\ri-548\sb20\nowidctlpar \f8 {\i\cf1 Hewlett-Packard Laboratories}{\b\cf1 
\par }\pard \s43\qc\ri-548\sb20\nowidctlpar {\i\cf1 1501 Page Mill Road}{\b\cf1 
\par }{\i\cf1 Palo Alto, CA 94304}{\b\cf1 
\par }{\i\cf1 lee@hpl.hp.com}{\b\cf1 
\par }\pard \s43\qc\ri-548\sb20\nowidctlpar {\b\cf1 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard\plain \s20\qc\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 July 7, 1995}{\b\f18\fs20\cf1 
\par }\pard \s20\qc\ri-548\sb140\sl280\slmult0\nowidctlpar {\b\f18\fs20\cf1 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard \s20\qc\ri-548\sb140\sl280\slmult0\nowidctlpar {\b\f18\fs20\cf1 
\par }\pard\plain \nowidctlpar \f8 
\par \pard \nowidctlpar 
\par \pard\plain \s35\qj\fi-532\li532\sb120\sl280\slmult0\nowidctlpar\pvpg\phpg\posx2707\posy9720\absh2390\absw6811 \f8 {\f18\fs20\cf1 Copyright (c) 1994 Hewlett-Packard Company}{\b\f18\fs20\cf1 
\par }\pard\plain \s17\qj\sb140\sl280\slmult0\nowidctlpar\pvpg\phpg\posx2707\posy9720\absh2390\absw6811 \f8 {\f18\fs20\cf1 Permission to use, copy, modify, distribute and sell this document for any purpose is hereby granted without fee,\~
provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation.}{\b\f18\fs20\cf1 
\par }\pard\plain \s35\fi-532\li532\ri-548\sb120\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 \page }{\field\fldedit{\*\fldinst {\f18\fs20\cf1  TOC \\t "section,1,subsection,2,subsubsection,3" }}{\fldrslt 
\par \pard\plain \s46\sb120\sa120\nowidctlpar\tqr\tldot\tx8812 \b\caps\f4\fs20 {\cf1 1  Introduction}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285519  {\field{\*\fldinst  PAGEREF _Toc330285519 }{\fldrslt 5}}}}
\par \pard \s46\sb120\sa120\nowidctlpar\tqr\tldot\tx8812 {\cf1 2  Structure of the library}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285520  {\field{\*\fldinst  PAGEREF _Toc330285520 }{\fldrslt 5}}}}
\par {\cf1 3  Requirements}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285521  {\field{\*\fldinst  PAGEREF _Toc330285521 }{\fldrslt 7}}}}
\par {\cf1 4  Core components}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285522  {\field{\*\fldinst  PAGEREF _Toc330285522 }{\fldrslt 7}}}}
\par \pard\plain \s47\nowidctlpar\tqr\tldot\tx8812 \scaps\f4\fs20 {\b\cf1 4.1 Operators}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285523  {\field{\*\fldinst  PAGEREF _Toc330285523 }{\fldrslt 7}}}}
\par \pard \s47\nowidctlpar\tqr\tldot\tx8812 {\b\cf1 4.2 Pair}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285524  {\field{\*\fldinst  PAGEREF _Toc330285524 }{\fldrslt 8}}}}
\par \pard\plain \s46\sb120\sa120\nowidctlpar\tqr\tldot\tx8812 \b\caps\f4\fs20 {\cf1 5  Iterators}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285525  {\field{\*\fldinst  PAGEREF _Toc330285525 }{\fldrslt 9}}}}
\par \pard\plain \s47\nowidctlpar\tqr\tldot\tx8812 \scaps\f4\fs20 {\b\cf1 5.1 Input iterators}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285526  {\field{\*\fldinst  PAGEREF _Toc330285526 }{\fldrslt 10}}}}
\par \pard \s47\nowidctlpar\tqr\tldot\tx8812 {\b\cf1 5.2 Output iterators}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285527  {\field{\*\fldinst  PAGEREF _Toc330285527 }{\fldrslt 10}}}}
\par {\b\cf1 5.3 Forward iterators}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285528  {\field{\*\fldinst  PAGEREF _Toc330285528 }{\fldrslt 11}}}}
\par {\b\cf1 5.4 Bidirectional iterators}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285529  {\field{\*\fldinst  PAGEREF _Toc330285529 }{\fldrslt 12}}}}
\par {\b\cf1 5.5 Random access iterators}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285530  {\field{\*\fldinst  PAGEREF _Toc330285530 }{\fldrslt 12}}}}
\par {\b\cf1 5.6 Iterator tags}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285531  {\field{\*\fldinst  PAGEREF _Toc330285531 }{\fldrslt 13}}}}
\par \pard\plain \s48\li240\nowidctlpar\tqr\tldot\tx8812 \i\f4\fs20 {\cf1 5.6.1 Examples of using iterator tags}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285532  {\field{\*\fldinst  PAGEREF _Toc330285532 }{\fldrslt 13}}}}
\par \pard \s48\li240\nowidctlpar\tqr\tldot\tx8812 {\cf1 5.6.2 Library defined primitives}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285533  {\field{\*\fldinst  PAGEREF _Toc330285533 }{\fldrslt 15}}}}
\par \pard\plain \s47\nowidctlpar\tqr\tldot\tx8812 \scaps\f4\fs20 {\b\cf1 5.7 Iterator operations}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285534  {\field{\*\fldinst  PAGEREF _Toc330285534 }{\fldrslt 17}}}}
\par \pard\plain \s46\sb120\sa120\nowidctlpar\tqr\tldot\tx8812 \b\caps\f4\fs20 {\cf1 6  Function objects}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285535  {\field{\*\fldinst  PAGEREF _Toc330285535 }{\fldrslt 18}}}}
\par \pard\plain \s47\nowidctlpar\tqr\tldot\tx8812 \scaps\f4\fs20 {\b\cf1 6.1 Base}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285536  {\field{\*\fldinst  PAGEREF _Toc330285536 }{\fldrslt 18}}}}
\par \pard \s47\nowidctlpar\tqr\tldot\tx8812 {\b\cf1 6.2 Arithmetic operations}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285537  {\field{\*\fldinst  PAGEREF _Toc330285537 }{\fldrslt 18}}}}
\par {\b\cf1 6.3 Comparisons}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285538  {\field{\*\fldinst  PAGEREF _Toc330285538 }{\fldrslt 19}}}}
\par {\b\cf1 6.4 Logical operations}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285539  {\field{\*\fldinst  PAGEREF _Toc330285539 }{\fldrslt 20}}}}
\par \pard\plain \s46\sb120\sa120\nowidctlpar\tqr\tldot\tx8812 \b\caps\f4\fs20 {\cf1 7  Allocators}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285540  {\field{\*\fldinst  PAGEREF _Toc330285540 }{\fldrslt 20}}}}
\par \pard\plain \s47\nowidctlpar\tqr\tldot\tx8812 \scaps\f4\fs20 {\b\cf1 7.1 Allocator requirements}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285541  {\field{\*\fldinst  PAGEREF _Toc330285541 }{\fldrslt 20}}}}
\par \pard \s47\nowidctlpar\tqr\tldot\tx8812 {\b\cf1 7.2 The default allocator}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285542  {\field{\*\fldinst  PAGEREF _Toc330285542 }{\fldrslt 21}}}}
\par \pard\plain \s46\sb120\sa120\nowidctlpar\tqr\tldot\tx8812 \b\caps\f4\fs20 {\cf1 8  Containers}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285543  {\field{\*\fldinst  PAGEREF _Toc330285543 }{\fldrslt 22}}}}
\par \pard\plain \s47\nowidctlpar\tqr\tldot\tx8812 \scaps\f4\fs20 {\b\cf1 8.1 Sequences}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285544  {\field{\*\fldinst  PAGEREF _Toc330285544 }{\fldrslt 24}}}}
\par \pard\plain \s48\li240\nowidctlpar\tqr\tldot\tx8812 \i\f4\fs20 {\cf1 8.1.1 Vector}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285545  {\field{\*\fldinst  PAGEREF _Toc330285545 }{\fldrslt 26}}}}
\par \pard \s48\li240\nowidctlpar\tqr\tldot\tx8812 {\cf1 8.1.3 Deque}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285546  {\field{\*\fldinst  PAGEREF _Toc330285546 }{\fldrslt 33}}}}
\par \pard\plain \s47\nowidctlpar\tqr\tldot\tx8812 \scaps\f4\fs20 {\b\cf1 8.2 Associative containers}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285547  {\field{\*\fldinst  PAGEREF _Toc330285547 }{\fldrslt 35}}}}
\par \pard\plain \s48\li240\nowidctlpar\tqr\tldot\tx8812 \i\f4\fs20 {\cf1 8.2.1 Set}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285548  {\field{\*\fldinst  PAGEREF _Toc330285548 }{\fldrslt 38}}}}
\par \pard \s48\li240\nowidctlpar\tqr\tldot\tx8812 {\cf1 8.2.2 Multiset}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285549  {\field{\*\fldinst  PAGEREF _Toc330285549 }{\fldrslt 40}}}}
\par {\cf1 8.2.3 Map}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285550  {\field{\*\fldinst  PAGEREF _Toc330285550 }{\fldrslt 41}}}}
\par {\cf1 8.2.4 Multimap}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285551  {\field{\*\fldinst  PAGEREF _Toc330285551 }{\fldrslt 44}}}}
\par \pard\plain \s46\sb120\sa120\nowidctlpar\tqr\tldot\tx8812 \b\caps\f4\fs20 {\cf1 9  Stream iterators}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285552  {\field{\*\fldinst  PAGEREF _Toc330285552 }{\fldrslt 46}}}}
\par \pard\plain \s47\nowidctlpar\tqr\tldot\tx8812 \scaps\f4\fs20 {\b\cf1 9.1 Istream Iterator}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285553  {\field{\*\fldinst  PAGEREF _Toc330285553 }{\fldrslt 46}}}}
\par \pard \s47\nowidctlpar\tqr\tldot\tx8812 {\b\cf1 9.2 Ostream iterator}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285554  {\field{\*\fldinst  PAGEREF _Toc330285554 }{\fldrslt 47}}}}
\par \pard\plain \s46\sb120\sa120\nowidctlpar\tqr\tldot\tx8812 \b\caps\f4\fs20 {\cf1 10  Algorithms}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285555  {\field{\*\fldinst  PAGEREF _Toc330285555 }{\fldrslt 48}}}}
\par \pard\plain \s47\nowidctlpar\tqr\tldot\tx8812 \scaps\f4\fs20 {\b\cf1 10.1 Non-mutating sequence operations}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285556  {\field{\*\fldinst  PAGEREF _Toc330285556 }{\fldrslt 48}}}}
\par \pard\plain \s48\li240\nowidctlpar\tqr\tldot\tx8812 \i\f4\fs20 {\cf1 10.1.1 For each}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285557  {\field{\*\fldinst  PAGEREF _Toc330285557 }{\fldrslt 48}}}}
\par \pard \s48\li240\nowidctlpar\tqr\tldot\tx8812 {\cf1 10.1.2 Find}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285558  {\field{\*\fldinst  PAGEREF _Toc330285558 }{\fldrslt 49}}}}
\par {\cf1 10.1.3 Adjacent find}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285559  {\field{\*\fldinst  PAGEREF _Toc330285559 }{\fldrslt 49}}}}
\par {\cf1 10.1.4 Count}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285560  {\field{\*\fldinst  PAGEREF _Toc330285560 }{\fldrslt 49}}}}
\par {\cf1 10.1.5 Mismatch}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285561  {\field{\*\fldinst  PAGEREF _Toc330285561 }{\fldrslt 50}}}}
\par {\cf1 10.1.6 Equal}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285562  {\field{\*\fldinst  PAGEREF _Toc330285562 }{\fldrslt 50}}}}
\par {\cf1 10.1.7 Search}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285563  {\field{\*\fldinst  PAGEREF _Toc330285563 }{\fldrslt 50}}}}
\par \pard\plain \s47\nowidctlpar\tqr\tldot\tx8812 \scaps\f4\fs20 {\b\cf1 10.2 Mutating sequence operations}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285564  {\field{\*\fldinst  PAGEREF _Toc330285564 }{\fldrslt 51}}}}
\par \pard\plain \s48\li240\nowidctlpar\tqr\tldot\tx8812 \i\f4\fs20 {\cf1 10.2.1 Copy}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285565  {\field{\*\fldinst  PAGEREF _Toc330285565 }{\fldrslt 51}}}}
\par \pard \s48\li240\nowidctlpar\tqr\tldot\tx8812 {\cf1 10.2.2 Swap}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285566  {\field{\*\fldinst  PAGEREF _Toc330285566 }{\fldrslt 51}}}}
\par {\cf1 10.2.3 Transform}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285567  {\field{\*\fldinst  PAGEREF _Toc330285567 }{\fldrslt 52}}}}
\par {\cf1 10.2.4 Replace}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285568  {\field{\*\fldinst  PAGEREF _Toc330285568 }{\fldrslt 52}}}}
\par {\cf1 10.2.5 Fill}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285569  {\field{\*\fldinst  PAGEREF _Toc330285569 }{\fldrslt 53}}}}
\par {\cf1 10.2.6 Generate}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285570  {\field{\*\fldinst  PAGEREF _Toc330285570 }{\fldrslt 53}}}}
\par {\cf1 10.2.7 Remove}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285571  {\field{\*\fldinst  PAGEREF _Toc330285571 }{\fldrslt 53}}}}
\par {\cf1 10.2.8 Unique}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285572  {\field{\*\fldinst  PAGEREF _Toc330285572 }{\fldrslt 54}}}}
\par {\cf1 10.2.9 Reverse}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285573  {\field{\*\fldinst  PAGEREF _Toc330285573 }{\fldrslt 54}}}}
\par {\cf1 10.2.10 Rotate}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285574  {\field{\*\fldinst  PAGEREF _Toc330285574 }{\fldrslt 55}}}}
\par {\cf1 10.2.11 Random shuffle}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285575  {\field{\*\fldinst  PAGEREF _Toc330285575 }{\fldrslt 55}}}}
\par {\cf1 10.2.12 Partitions}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285576  {\field{\*\fldinst  PAGEREF _Toc330285576 }{\fldrslt 56}}}}
\par \pard\plain \s47\nowidctlpar\tqr\tldot\tx8812 \scaps\f4\fs20 {\b\cf1 10.3 Sorting and related operations}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285577  {\field{\*\fldinst  PAGEREF _Toc330285577 }{\fldrslt 56}}}}
\par \pard\plain \s48\li240\nowidctlpar\tqr\tldot\tx8812 \i\f4\fs20 {\cf1 10.3.1 Sort}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285578  {\field{\*\fldinst  PAGEREF _Toc330285578 }{\fldrslt 56}}}}
\par \pard \s48\li240\nowidctlpar\tqr\tldot\tx8812 {\cf1 10.3.2 Nth element}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285579  {\field{\*\fldinst  PAGEREF _Toc330285579 }{\fldrslt 58}}}}
\par {\cf1 10.3.3 Binary search}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285580  {\field{\*\fldinst  PAGEREF _Toc330285580 }{\fldrslt 58}}}}
\par {\cf1 10.3.4 Merge}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285581  {\field{\*\fldinst  PAGEREF _Toc330285581 }{\fldrslt 59}}}}
\par {\cf1 10.3.5 Set operations on sorted structures}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285582  {\field{\*\fldinst  PAGEREF _Toc330285582 }{\fldrslt 60}}}}
\par {\cf1 10.3.6 Heap operations}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285583  {\field{\*\fldinst  PAGEREF _Toc330285583 }{\fldrslt 62}}}}
\par {\cf1 10.3.7 Minimum and maximum}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285584  {\field{\*\fldinst  PAGEREF _Toc330285584 }{\fldrslt 63}}}}
\par {\cf1 10.3.8 Lexicographical comparison}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285585  {\field{\*\fldinst  PAGEREF _Toc330285585 }{\fldrslt 64}}}}
\par {\cf1 10.3.9 Permutation generators}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285586  {\field{\*\fldinst  PAGEREF _Toc330285586 }{\fldrslt 64}}}}
\par \pard\plain \s47\nowidctlpar\tqr\tldot\tx8812 \scaps\f4\fs20 {\b\cf1 10.4 Generalized numeric operations}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285587  {\field{\*\fldinst  PAGEREF _Toc330285587 }{\fldrslt 65}}}}
\par \pard\plain \s48\li240\nowidctlpar\tqr\tldot\tx8812 \i\f4\fs20 {\cf1 10.4.1 Accumulate}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285588  {\field{\*\fldinst  PAGEREF _Toc330285588 }{\fldrslt 65}}}}
\par \pard \s48\li240\nowidctlpar\tqr\tldot\tx8812 {\cf1 10.4.2 Inner product}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285589  {\field{\*\fldinst  PAGEREF _Toc330285589 }{\fldrslt 65}}}}
\par {\cf1 10.4.3 Partial sum}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285590  {\field{\*\fldinst  PAGEREF _Toc330285590 }{\fldrslt 65}}}}
\par {\cf1 10.4.4 Adjacent difference}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285591  {\field{\*\fldinst  PAGEREF _Toc330285591 }{\fldrslt 66}}}}
\par \pard\plain \s46\sb120\sa120\nowidctlpar\tqr\tldot\tx8812 \b\caps\f4\fs20 {\cf1 11  Adaptors}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285592  {\field{\*\fldinst  PAGEREF _Toc330285592 }{\fldrslt 66}}}}
\par \pard\plain \s47\nowidctlpar\tqr\tldot\tx8812 \scaps\f4\fs20 {\b\cf1 11.1 Container adaptors}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285593  {\field{\*\fldinst  PAGEREF _Toc330285593 }{\fldrslt 66}}}}
\par \pard\plain \s48\li240\nowidctlpar\tqr\tldot\tx8812 \i\f4\fs20 {\cf1 11.1.1 Stack}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285594  {\field{\*\fldinst  PAGEREF _Toc330285594 }{\fldrslt 66}}}}
\par \pard \s48\li240\nowidctlpar\tqr\tldot\tx8812 {\cf1 11.1.2 Queue}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285595  {\field{\*\fldinst  PAGEREF _Toc330285595 }{\fldrslt 67}}}}
\par {\cf1 11.1.3 Priority queue}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285596  {\field{\*\fldinst  PAGEREF _Toc330285596 }{\fldrslt 68}}}}
\par \pard\plain \s47\nowidctlpar\tqr\tldot\tx8812 \scaps\f4\fs20 {\b\cf1 11.2 Iterator adaptors}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285597  {\field{\*\fldinst  PAGEREF _Toc330285597 }{\fldrslt 69}}}}
\par \pard\plain \s48\li240\nowidctlpar\tqr\tldot\tx8812 \i\f4\fs20 {\cf1 11.2.1 Reverse iterators}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285598  {\field{\*\fldinst  PAGEREF _Toc330285598 }{\fldrslt 69}}}}
\par \pard \s48\li240\nowidctlpar\tqr\tldot\tx8812 {\cf1 11.2.2 Insert iterators}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285599  {\field{\*\fldinst  PAGEREF _Toc330285599 }{\fldrslt 72}}}}
\par {\cf1 11.2.3 Raw storage iterator}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285600  {\field{\*\fldinst  PAGEREF _Toc330285600 }{\fldrslt 74}}}}
\par \pard\plain \s47\nowidctlpar\tqr\tldot\tx8812 \scaps\f4\fs20 {\b\cf1 11.3 Function adaptors}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285601  {\field{\*\fldinst  PAGEREF _Toc330285601 }{\fldrslt 75}}}}
\par \pard\plain \s48\li240\nowidctlpar\tqr\tldot\tx8812 \i\f4\fs20 {\cf1 11.3.1 Negators}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285602  {\field{\*\fldinst  PAGEREF _Toc330285602 }{\fldrslt 75}}}}
\par \pard \s48\li240\nowidctlpar\tqr\tldot\tx8812 {\cf1 11.3.2 Binders}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285603  {\field{\*\fldinst  PAGEREF _Toc330285603 }{\fldrslt 75}}}}
\par {\cf1 11.3.3 Adaptors for pointers to functions}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285604  {\field{\*\fldinst  PAGEREF _Toc330285604 }{\fldrslt 76}}}}
\par \pard\plain \s46\sb120\sa120\nowidctlpar\tqr\tldot\tx8812 \b\caps\f4\fs20 {\cf1 12  Memory Handling}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285605  {\field{\*\fldinst  PAGEREF _Toc330285605 }{\fldrslt 77}}}}
\par \pard\plain \s47\nowidctlpar\tqr\tldot\tx8812 \scaps\f4\fs20 {\b\cf1 12.1 Primitives}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285606  {\field{\*\fldinst  PAGEREF _Toc330285606 }{\fldrslt 77}}}}
\par \pard \s47\nowidctlpar\tqr\tldot\tx8812 {\b\cf1 12.2 Specialized algorithms}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285607  {\field{\*\fldinst  PAGEREF _Toc330285607 }{\fldrslt 78}}}}
\par \pard\plain \s46\sb120\sa120\nowidctlpar\tqr\tldot\tx8812 \b\caps\f4\fs20 {\cf1 13  Acknowledgments}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285608  {\field{\*\fldinst  PAGEREF _Toc330285608 }{\fldrslt 79}}}}
\par \pard \s46\sb120\sa120\nowidctlpar\tqr\tldot\tx8812 {\cf1 14  Bibliography}\tab {\field{\*\fldinst  GOTOBUTTON _Toc330285609  {\field{\*\fldinst  PAGEREF _Toc330285609 }{\fldrslt 80}}}}
\par \pard\plain \s35\fi-532\li532\ri-548\sb120\sl280\slmult0\nowidctlpar \f8 }}\pard\plain \s35\fi-532\li532\ri-548\sb120\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
\par \page 
\par }\pard\plain \s34\ri-548\sb320\sl280\slmult0\nowidctlpar \f8 {\b\f9\cf1 {\*\bkmkstart _Toc330285519}1  Introduction}{\f9\cf1 {\*\bkmkend _Toc330285519}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 The Standard Template Library provides a set of well structured generic C++ components that work together in a seamless way. Special care has been taken to ensure th
at all the template algorithms work not only on the data structures in the library, but also on built-in C++ data structures. For example, all the algorithms work on regular pointers. The orthogonal design of the library allows programmers to use library 
data structures with their own algorithms, and to use library algorithms with their own data structures. The well specified semantic and complexity requirements guarantee that a user component will work with the library, and that it will work efficiently.
 This flexibility ensures the widespread utility of the library.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
Another important consideration is efficiency. C++ is successful because it combines expressive power with efficiency. Much effort has been spent to verify that every template component in the library has a generic implementation that performs within a fe
w percentage points of the efficiency of the corresponding hand coded routine. 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 The third consideration in the design has been to develop a library structure that, while being natural and easy to grasp, is based on a firm theoretical foundation.
\par }\pard\plain \s34\ri-548\sb320\sl280\slmult0\nowidctlpar \f8 {\b\f9\cf1 {\*\bkmkstart _Toc330285520}2  Structure of the library}{\f9\cf1 {\*\bkmkend _Toc330285520}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 The library contains five main kinds of components: 
\par }\pard\plain \s19\fi-230\li590\ri-548\sb40\sl260\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 \endash \tab algorithm: defines a computational procedure.
\par }\pard \s19\fi-230\li590\ri-548\sb40\sl260\slmult0\nowidctlpar {\f18\fs20\cf1 \endash \tab container: manages a set of memory locations.
\par \endash \tab iterator: provides a means for an algorithm to traverse through a container.
\par \endash \tab function object: encapsulates a function in an object for use by other components.
\par \endash \tab adaptor: adapts a component to provide a different interface.
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 Such decomposition allows us to dramatically reduce the
 component space. For example, instead of providing a search member function for every kind of container we provide a single version that works with all of them as long as a basic set of requirements is satisfied. 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
The following description helps clarify the structure of the library. If software components are tabulated as a three-dimensional array, where one dimension represents different data types (e.g. int, double), the second dimension represents different cont
ainers (e.g. vector, linked-list, file), a
nd the third dimension represents different algorithms on the containers (e.g. searching, sorting, rotation), if i, j, and k are the size of the dimensions, then i*j*k different versions of code have to be designed. By using template functions that are pa
rameterized by a data type, we need only j*k versions. Further, by making our algorithms work on different containers, we need merely j+k versions. This significantly simplifies software design work and also makes it possible to use components in the libr
ary together with user defined components in a very flexible way. A user may easily define a specialized container class and use the library\rquote 
s sort function to sort it. A user may provide a different comparison function for the sort either as a regular poin
ter to a comparison function, or as a function object (an object with an operator() defined) that does the comparisons. If a user needs to iterate through a container in the reverse direction, the reverse_iterator adaptor allows that.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 The library extends th
e basic C++ paradigms in a consistent way, so it is easy for a C/C++ programmer to start using the library. For example, the library contains a merge template function. When a user has two arrays a and b to be merged into c it can be done with:
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 int a[1000];
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 int b[2000];
\par int c[3000];
\par ...
\par merge(a, a + 1000, b, b + 2000, c);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
When a user wants to merge a vector and a list (both of which are template classes in the library) and put the result into a freshly allocated uninitialized storage it can be done with:
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 vector<Employee> a;
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 list<Employee> b;
\par ...
\par Employee* c = allocate(a.size() + b.size(), (Employee*)0);
\par merge(a.begin(), a.end(), b.begin(), b.end(), 
\par \tab raw_storage_iterator<Employee*, Employee>(c));
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 where begin() and end() are member functions of containers that return the right types of iterators or pointer-like objects that allow the merge to do the job and }{
\f3\fs18\cf1 raw_storage_iterator is an adapter that allows algorithms to put results directly into uninitialized memory by calling the appropriate copy constructor. 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
In many cases it is useful to iterate through input/output streams in the same way as through regular data structures. For example, if we want to merge two data structures and then store them in a file, it would be nice to avoid creation of an auxiliary d
ata structure for the result, instead storing the result directly into the corresponding file. The library provides both istream_iterator and ostream_iterator template classes to make many of the library algorithms work with I/O streams that represent hom
ogenous aggregates of data. Here is a program that reads a file of integers from the standard input, removes all those that are divisible by its command argument, and writes the result to the standard output:
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 main(int argc, char** argv) \{
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab if (argc != 2) throw(\rdblquote usage: remove_if_divides integer\\n\rdblquote );
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab remove_copy_if(istream_iterator<int>(cin), istream_iterator<int>(),
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab ostream_iterator<int>(cout, \rdblquote \\n\rdblquote ),
\par \tab \tab not1(bind2nd(modulus<int>(), atoi(argv[1]))));
\par \}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 All the work is done by remove_copy_if which reads inte
gers one by one until the input iterator becomes equal to the end-of-stream iterator that is constructed by the constructor with no arguments. (In general, all the algorithms work in a \ldblquote from here to there\rdblquote 
 fashion taking two iterators that signify the beg
inning and the end of the input.) Then remove_copy_if writes the integers that pass the test onto the output stream through the output iterator that is bound to cout. As a predicate, remove_copy_if uses a function object constructed from a function object
, 
modulus<int>, which takes i and j and returns i%j, as a binary predicate and makes it into a unary predicate by using bind2nd to bind the second argument to the command line argument, atoi(argv[1]). Then the negation of this unary predicate is obtained us
ing function adaptor not1.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 A somewhat more realistic example is a filter program that takes a file and randomly shuffles its lines.
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 main(int argc, char**) \{
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab if (argc != 1) throw(\rdblquote usage: shuffle\\n\rdblquote );
\par \tab vector<string> v;
\par \tab copy(istream_iterator<string>(cin), istream_iterator<string>(),
\par \tab \tab inserter(v, v.end()));
\par  \tab random_shuffle(v.begin(), v.end());
\par  \tab copy(v.begin(), v.end(), ostream_iterator<string>(cout));
\par \}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
In this example, copy moves lines from the standard input into a vector, but since the vector is not pre-allocated it uses an insert iterator to insert the lines one by one into the vector. (This technique allows all of the copying functions to work in th
e usual overwrite mode as well as in the insert mode.) Then random_shuffle shuffles the vector and another call to copy copies it onto the cout stream. 
\par }\pard\plain \s34\ri-548\sb320\sl280\slmult0\nowidctlpar \f8 {\b\f9\cf1 {\*\bkmkstart _Toc330285521}3  Requirements}{\f9\cf1 {\*\bkmkend _Toc330285521}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
To ensure that the different components in a library work together, they must satisfy some basic requirements. Requirements should be as general as possible, so instead of saying \ldblquote class X has to define a member function operator++(),\rdblquote 
 we say \ldblquote for any object x of class X, ++x is defined.\rdblquote  (It is unspecified whether the operator is a member or a global function.) Requirements are stated in 
terms of well-defined expressions, which define valid terms of the types that satisfy the requirements. For every set of requirements there is a table that specifies an initial set of the valid expressions and their semantics. Any generic algorithm that u
ses the requirements has to be written in terms of the valid expressions for its formal type parameters.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 If an operation is required to be linear time, it means no worse than linear time, and a constant time operation satisfies the requirement.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 In some case
s we present the semantic requirements using C++ code. Such code is intended as a specification of equivalence of a construct to another construct, not necessarily as the way the construct must be implemented (although in some cases the code given is unam
biguously the optimum implementation).
\par }\pard\plain \s34\ri-548\sb320\sl280\slmult0\nowidctlpar \f8 {\b\f9\cf1 {\*\bkmkstart _Toc330285522}4  Core components}{\f9\cf1 {\*\bkmkend _Toc330285522}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 This section contains some basic template functions and classes that are used throughout the rest of the library.
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285523}4.1 Operators}{\f9\fs22\cf1 {\*\bkmkend _Toc330285523}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 To avoid redundant definitions of operator!= out of operator== and operators>, <=, and >= out of operator< the library provides the following:
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 inline bool operator!=(const T& x, const T& y) \{
\par \tab return !(x == y);
\par \}
\par 
\par template <class T>
\par inline bool operator>(const T& x, const T& y) \{
\par \tab return y < x;
\par \}
\par 
\par template <class T>
\par inline bool operator<=(const T& x, const T& y) \{
\par \tab return !(y < x);
\par \}
\par 
\par template <class T>
\par inline bool operator>=(const T& x, const T& y) \{
\par \tab return !(x < y);
\par \}
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285524}4.2 Pair}{\f9\fs22\cf1 {\*\bkmkend _Toc330285524}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 The library includes templates for heterogeneous pairs of values.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class T1, class T2>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 struct pair \{
\par \tab T1 first;
\par \tab T2 second;
\par \tab pair(const T1& x, const T2& y) : first(x), second(y) \{\}
\par \};
\par \tab 
\par template <class T1, class T2>
\par inline bool operator==(const pair<T1, T2>& x, const pair<T1, T2>& y) \{
\par \tab return x.first == y.first && x.second == y.second;
\par \}
\par 
\par template <class T1, class T2>
\par inline bool operator<(const pair<T1, T2>& x, const pair<T1, T2>& y) \{
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab return x.first < y.first || (!(y.first < x.first) && x.second < y.second);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 The library provides a matching template function make_pair to simplify their construction. Instead of saying, for example,
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 return pair<int, double>(5, 3.1415926); // explicit types
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 one may say
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 return make_pair(5, 3.1415926); // types are deduced
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 
\par template <class T1, class T2> 
\par inline pair<T1, T2> make_pair(const T1& x, const T2& y) \{
\par \tab return pair<T1, T2>(x, y);
\par }\pard\plain \s34\ri-548\sb320\sl280\slmult0\nowidctlpar \f8 {\b\f9\cf1 {\*\bkmkstart _Toc330285525}5  Iterators}{\f9\cf1 {\*\bkmkend _Toc330285525}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
Iterators are a generalization of pointers that allow a programmer to work with different data structures (containers) in a uniform manner. To be able to construct template algorithms that wor
k correctly and efficiently on different types of data structures, we need to formalize not just the interfaces but also the semantics and complexity assumptions of iterators. Iterators are objects that have operator* returning a value of some class or bu
ilt-in type T called a value type of the iterator. For every iterator type X for which equality is defined, there is a corresponding signed integral type called the distance type of the iterator. 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 Since iterators are a generalization of pointers, their sema
ntics is a generalization of the semantics of pointers in C++. This assures that every template function that takes iterators works with regular pointers. Depending on the operations defined on them, there are five categories of iterators: input iterators
, output iterators, forward iterators, bidirectional iterators and random access iterators. Forward iterators satisfy all the requirements of the input and output iterators and can be used whenever either kind is specified. Bidirectional iterators satisfy
 a
ll the requirements of the forward iterators and can be used whenever a forward iterator is specified. Random access iterators satisfy all the requirements of bidirectional iterators and can be used whenever a bidirectional iterator is specified. There is
 an additional attribute that forward, bidirectional and random access iterators might have, that is, they can be mutable or constant depending on whether the result of the operator* behaves as a reference or as a reference to a constant. Constant iterato
rs do not satisfy the requirements for output iterators.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
Just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element of the array, so for any iterator type there is an iterator value that points past the last element of a corresponding container. These values ar
e called past-the-end values. Values of the iterator for which the operator* is defined are called dereferenceable. The library never assumes that past-the-end values are dereferenceable. Iterators mig
ht also have singular values that are not associated with any container. For example, after the declaration of an uninitialized pointer x (as with int* x;), x should always be assumed to have a singular value of a pointer. Results of most expressions are 
undefined for singular values. The only exception is an assignment of a non-singular value to an iterator that holds a singular value. In this case the singular value is overwritten the same way as any other value. Dereferenceable and past-the-end values 
are always non-singular. 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
An iterator j is called reachable from an iterator i if and only if there is a finite sequence of applications of operator++ to i that makes i == j. If i and j refer to the same container, then either j is reachable from i, or i is reachable from j, or bo
th (i == j).
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 Most of the library\rquote 
s algorithmic templates that operate on data structures have interfaces that use ranges. A range is a pair of iterators that designate the beginning and end of the computation. A range [i, i) is an em
pty range; in general, a range [i, j) refers to the elements in the data structure starting with the one pointed to by i and up to but not including the one pointed to by j. Range [i, j) is valid if and only if j is reachable from i. The result of the app
lication of the algorithms in the library to invalid ranges is undefined.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 All the categories of iterators require only those functions that are realizable for a given category in constant time (amortized). Therefore, requirement tables for the iterators do 
not have a complexity column.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
In the following sections, we assume: a and b are values of X, n is a value of the distance type Distance, u, tmp, and m are identifiers, r and s are lvalues of X, t is a value of value type T.
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285526}5.1 Input iterators}{\f9\fs22\cf1 {\*\bkmkend _Toc330285526}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 A class or a built-in type X satisfies the requirements of an input iterator for the value type T if the following expressions are valid:
\par }\pard \s17\qc\ri-548\sb140\sl280\slmult0\nowidctlpar {\b\cf1 Table 2: Input iterator requirements
\par }\pard \s17\qc\ri-548\sb140\sl280\slmult0\nowidctlpar {\cf1 
\par }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx2808\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx4680\clbrdrt\brdrs\brdrw15 \clbrdrl
\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx6696\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx10440 \pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 expression\cell 
}\pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 return type\cell }\pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 operational semantics\cell }\pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 assertion/note
\par }\pard\plain \s21\qj\sl280\slmult0\nowidctlpar\intbl \f8 {\fs20\cf1 pre/post-condition\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 
\cellx2808\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx4680\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx6696\clbrdrt\brdrs\brdrw15 \clbrdrl
\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx10440 \pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X(a)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 a == X(a).
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 note: a destructor is assumed.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X u(a);
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 X u = a;\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\fs20\cf1 post: u == a.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a == b\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 
convertible to bool\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 == is an equivalence relation.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain 
\s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a != b\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 convertible to bool\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 !(a == b)\cell }\pard 
\s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard\plain \widctlpar\intbl \f8 {\f3\fs18\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 *a\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 
convertible to T \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 pre: a is dereferenceable.
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 a == b implies *a == *b.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 ++r\cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\f3\fs18\cf1 X&\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 pre: r is dereferenceable.
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 post: r is dereferenceable or r is past-the-end.
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 &r == &++r.\cell }\pard\plain \widctlpar\intbl \f8 {\f3\fs18\cf1 \row }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx2808\clbrdrt
\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx4680\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx6696\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb
\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx10440 \pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 r++\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 X\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {
\f3\fs18\cf1 \{ X tmp = r;
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 ++r;
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 return tmp; \}\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard\plain \widctlpar\intbl \f8 {\f3\fs18\cf1 \row }\pard \qc\ri-548\sl280\slmult0\nowidctlpar {
\f3\fs18\cf1 
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 NOTE: For input iterators, r == s does not imply ++r == ++s. (Equality does not guarantee the substitution property or referenti
al transparency.) Algorithms on input iterators should never attempt to pass through the same iterator twice. They should be single pass algorithms. Value type }{\i\f3\fs18\cf1 T}{\i\f18\fs20\cf1 
 is not required to be an lvalue type. These algorithms can be used with istreams as the source of the input data through the istream_iterator class.}{\f18\fs20\cf1 
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285527}5.2 Output iterators}{\f9\fs22\cf1 {\*\bkmkend _Toc330285527}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 A class or a built-in type X satisfies the requirements of an output iterator if the following expressions are valid:
\par }\pard \s17\qc\ri-548\sb140\sl280\slmult0\nowidctlpar {\b\cf1 Table 3: Output iterator requirements
\par }\pard \s17\qc\ri-548\sb140\sl280\slmult0\nowidctlpar {\cf1 
\par }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx2808\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx4536\clbrdrt\brdrs\brdrw15 \clbrdrl
\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx6552\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx10152 \pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 expression\cell 
}\pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 return type\cell }\pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 operational semantics\cell }\pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 assertion/note
\par }\pard\plain \s21\qj\sl280\slmult0\nowidctlpar\intbl \f8 {\fs20\cf1 pre/post-condition\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 
\cellx2808\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx4536\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx6552\clbrdrt\brdrs\brdrw15 \clbrdrl
\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx10152 \pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X(a)\cell \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\fs20\cf1 *a = t is equivalent to *X(a) = t.
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 note: a destructor is assumed.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X u(a);
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 X u = a;\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard\plain \widctlpar\intbl \f8 {\f3\fs18\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 *a = t\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 result is not used
\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 \cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 
++r\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 X&\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard\plain \widctlpar\intbl \f8 {
\f3\fs18\cf1 \row }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx2808\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx4536\clbrdrt
\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx6552\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx10152 \pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {
\f3\fs18\cf1 r++\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 X or X&\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 \cell }\pard\plain \widctlpar\intbl \f8 
{\fs20\cf1 \row }\pard \qc\ri-548\sl280\slmult0\nowidctlpar {\fs20\cf1 
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\fs20\cf1 
NOTE: The only valid use of an operator* is on the left side of the assignment statement. Assignment through the same value of the iterator happens only once. Algorithms on output iterators should never attempt to pass through the same iterator twice. The
y should be single pass algorithms. Equality and i
nequality are not necessarily defined. Algorithms that take output iterators can be used with ostreams as the destination for placing data through the ostream_iterator class as well as with insert iterators and insert pointers. In particular, the followin
g two conditions should hold: first, any iterator value should be assigned through before it is incremented (this is, for an output iterator i, i++; i++; is not a valid code sequence); second, any value of an output iterator may have at most one active co
py at any given time (for example, i = j; *++i = a; *j = b; is not a valid code sequence).
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285528}5.3 Forward iterators}{\f9\fs22\cf1 {\*\bkmkend _Toc330285528}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 A class or a built-in type X satisfies the requirements of a forward iterator if the following expressions are \line valid:
\par }\pard \s17\qc\ri-548\sb140\sl280\slmult0\nowidctlpar {\b\cf1 Table 4: Forward iterator requirements
\par }\pard \s17\qc\ri-548\sb140\sl280\slmult0\nowidctlpar {\cf1 
\par }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx2808\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx4680\clbrdrt\brdrs\brdrw15 \clbrdrl
\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx6696\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx10440 \pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 expression\cell 
}\pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 return type\cell }\pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 operational semantics\cell }\pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 assertion/note
\par }\pard\plain \s21\qj\sl280\slmult0\nowidctlpar\intbl \f8 {\fs20\cf1 pre/post-condition\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 
\cellx2808\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx4680\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx6696\clbrdrt\brdrs\brdrw15 \clbrdrl
\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx10440 \pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X u;\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 note: u might have a singular value. 
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 note: a destructor is assumed.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X()\cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 note: X() might be singular.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row 
}\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X(a)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\f3\fs18\cf1 a == X(a).\cell }\pard\plain \widctlpar\intbl \f8 {\f3\fs18\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X u(a);
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 X u = a;\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 X u; u = a;\cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\fs20\cf1 post: u == a.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a == b\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 
convertible to bool\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 == is an equivalence relation.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain 
\s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a != b\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 convertible to bool\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 !(a == b)\cell }\pard 
\s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard\plain \widctlpar\intbl \f8 {\f3\fs18\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 r = a\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 X&
\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 post: r == a.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {
\f3\fs18\cf1 *a\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 convertible to T
\par \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 pre: a is dereferenceable.
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 a == b implies *a == *b.
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 If X is mutable, *a = t is valid.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 ++r\cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\f3\fs18\cf1 X&\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 pre: r is dereferenceable.
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 post: r is dereferenceable or r is past-the-end.
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 r == s and r is dereferenceable implies ++r == ++s.
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 &r == &++r.\cell }\pard\plain \widctlpar\intbl \f8 {\f3\fs18\cf1 \row }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx2808\clbrdrt
\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx4680\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx6696\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb
\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx10440 \pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 r++\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 X\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {
\f3\fs18\cf1 \{ X tmp = r;
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 ++r;
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 return tmp; \}\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard\plain \widctlpar\intbl \f8 {\f3\fs18\cf1 \row }\pard \qc\ri-548\sl280\slmult0\nowidctlpar {
\f3\fs18\cf1 
\par }\pard \qc\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 NOTE: The fact that r == s implies ++r == ++s (which is not true for inpu
t and output iterators) and the removal on the restrictions on the number of the assignments through the iterator (which applies to output iterators) allows the use of multi-pass one-directional algorithms with forward iterators.
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285529}5.4 Bidirectional iterators}{\f9\fs22\cf1 {\*\bkmkend _Toc330285529}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 A class or a built-in type X satisfies the requirements of a bidirectional iterator if to the table that specifies forward iterators we add the following lines:
\par }\pard \s17\qc\ri-548\sb140\sl280\slmult0\nowidctlpar {\b\cf1 Table 5: Bidirectional iterator requirements (in addition to forward iterator)
\par }\pard \s17\qc\ri-548\sb140\sl280\slmult0\nowidctlpar {\cf1 
\par }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx2808\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx4680\clbrdrt\brdrs\brdrw15 \clbrdrl
\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx6696\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx10440 \pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 expression\cell 
}\pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 return type\cell }\pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 operational semantics\cell }\pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 assertion/note
\par }\pard\plain \s21\qj\sl280\slmult0\nowidctlpar\intbl \f8 {\fs20\cf1 pre/post-condition\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 
\cellx2808\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx4680\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx6696\clbrdrt\brdrs\brdrw15 \clbrdrl
\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx10440 \pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 --r\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 X&\cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 pre: there exists s such that r == ++s.
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 post: s is dereferenceable.
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 --(++r) == r.
\par --r == --s implies r == s.
\par &r == &--r.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx2808\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 
\clbrdrr\brdrs\brdrw15 \cellx4680\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx6696\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx10440 \pard\plain 
\s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 r--\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 X\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \{ X tmp = r;
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 --r;
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 return tmp; \}\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard\plain \widctlpar\intbl \f8 {\f3\fs18\cf1 \row }\pard \qc\ri-548\sl280\slmult0\nowidctlpar {
\f3\fs18\cf1 
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 NOTE: Bidirectional iterators allow algorithms to move iterators backward as well as forward.
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285530}5.5 Random access iterators}{\f9\fs22\cf1 {\*\bkmkend _Toc330285530}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 A class or a built-in type X satisfies the requirements of a random access iterator if to the table that specifies bidirectional iterators we add the following lines:
\par }\pard \s17\qc\ri-548\sb140\sl280\slmult0\nowidctlpar {\b\cf1 Table 6: Random access iterator requirements (in addition to bidirectional iterator)
\par }\pard \s17\qc\ri-548\sb140\sl280\slmult0\nowidctlpar {\cf1 
\par }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx2808\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx4680\clbrdrt\brdrs\brdrw15 \clbrdrl
\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx7128\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx10872 \pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 expression\cell 
}\pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 return type\cell }\pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 operational semantics\cell }\pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 assertion/note
\par }\pard\plain \s21\qj\sl280\slmult0\nowidctlpar\intbl \f8 {\fs20\cf1 pre/post-condition\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 
\cellx2808\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx4680\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx7128\clbrdrt\brdrs\brdrw15 \clbrdrl
\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx10872 \pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 r += n\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 X&\cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\f3\fs18\cf1 \{ Distance m = n;
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 if (m >= 0)
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 while (m--) ++r; 
\par else
\par while (m++) --r; 
\par return r; \}\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard\plain \widctlpar\intbl \f8 {\f3\fs18\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a + n
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 n + a\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 X\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \{ X tmp = a; 
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 return tmp += n; \}\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 a + n == n + a.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0
\nowidctlpar\intbl \f8 {\f3\fs18\cf1 r -= n\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 X&\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 return r += -n;\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {
\f3\fs18\cf1 \cell }\pard\plain \widctlpar\intbl \f8 {\f3\fs18\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a - n
\par }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 X\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \{ X tmp = a; 
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 return tmp -= n; \}\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard\plain \widctlpar\intbl \f8 {\f3\fs18\cf1 \row }\pard\plain \s21\qc\sl280\slmult0
\nowidctlpar\intbl \f8 {\f3\fs18\cf1 b - a\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 Distance\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 
pre: there exists a value n of Distance such that a + n = b.
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 b == a + (b - a).\cell }\pard\plain \widctlpar\intbl \f8 {\f3\fs18\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a[n]\cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\fs20\cf1 convertible to T\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 *(a + n)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard\plain \widctlpar\intbl \f8 {\f3\fs18\cf1 \row 
}\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a < b\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 convertible to bool\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 b - a > 0\cell }\pard 
\s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 < is a total ordering relation\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a > b\cell }{\fs20\cf1 convertible to bool
\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 b < a\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 > }{\fs20\cf1 is a total ordering relation opposite to <.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row 
}\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a >= b\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 convertible to bool\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 !(a < b)\cell }\pard 
\s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard\plain \widctlpar\intbl \f8 {\f3\fs18\cf1 \row }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx2808\clbrdrt\brdrs\brdrw15 
\clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx4680\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx7128\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 
\clbrdrr\brdrs\brdrw15 \cellx10872 \pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a <= b\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 convertible to bool\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {
\f3\fs18\cf1 !(a > b)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard\plain \widctlpar\intbl \f8 {\f3\fs18\cf1 \row }\pard \qc\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285531}5.6 Iterator tags}{\f9\fs22\cf1 {\*\bkmkend _Toc330285531}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
To implement algorithms only in terms of iterators, it is often necessary to infer both of the value type and the distance type from the iterator. To enable this task it is required that for an iterator i of any category other than output it
erator, the expression value_type(i) returns (T*)(0) and the expression distance_type(i) returns (Distance*)(0). For output iterators, these expressions are not required. 
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285532}5.6.1 Examples of using iterator tags}{\f9\fs20\cf1 {\*\bkmkend _Toc330285532}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 For all the regular pointer types we can define value_type and distance_type with the help of:
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 inline T* value_type(const T*) \{ return (T*)(0); \}
\par 
\par template <class T>
\par inline ptrdiff_t* distance_type(const T*) \{ return (ptrdiff_t*)(0); \}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 Then, if we want to implement a generic reverse function, we do the following:
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class BidirectionalIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 inline void reverse(BidirectionalIterator first, BidirectionalIterator last) \{
\par \tab __reverse(first, last, value_type(first), distance_type(first));
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 where __reverse is defined as:
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class BidirectionalIterator, class T, class Distance>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 void __reverse(BidirectionalIterator first, \tab \tab BidirectionalIterator last, \tab \tab T*,
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab  Distance*) \{
\par \tab Distance n;
\par \tab distance(first, last, n); // see Iterator operations section
\par \tab --n;
\par \tab while (n > 0) \{
\par \tab \tab T tmp = *first;
\par \tab \tab *first++ = *--last;
\par \tab \tab *last = tmp;
\par \tab \tab n -= 2;
\par \tab \}
\par \}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 If there is an additional pointer type __huge such that the difference of two __huge pointers is of the type long long, we define:
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 inline T* value_type(const T __huge *) \{ return (T*)(0); \}
\par 
\par template <class T>
\par inline long long* distance_type(const T __huge *) \{ return (long long*)(0); \}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 It is often desirable for a template function to find out what is the most specific category of its iterator argument, so that the funct
ion can select the most efficient algorithm at compile time. To facilitate this, the library introduces category tag classes which are used as compile time tags for algorithm selection. They are: input_iterator_tag, output_iterator_tag, forward_iterator_t
ag, bidirectional_iterator_tag and random_access_iterator_tag. Every iterator i must have an expression iterator_category(i) defined on it that returns the most specific category tag that describes its behavior. For example, we define that all the pointer
 types are in the random access iterator category by:
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 inline random_access_iterator_tag iterator_category(const T*) \{
\par \tab return random_access_iterator_tag(); 
\par \}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 For a user-defined iterator BinaryTreeIterator, it can be included into the bidirectional iterator category by saying:
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 inline bidirectional_iterator_tag iterator_category(
\par \tab \tab const BinaryTreeIterator<T>&) \{
\par \tab return bidirectional_iterator_tag();
\par \}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 If a template function evolve is well defined for bidirectional iterators, but can be implemented more efficiently for random access iterators, then the implementation is like:

\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class BidirectionalIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 inline void evolve(BidirectionalIterator first, BidirectionalIterator last)
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab evolve(first, last, iterator_category(first));
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \}
\par 
\par template <class BidirectionalIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 void evolve(BidirectionalIterator first, BidirectionalIterator last, bidirectional_iterator_tag) 
\{
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab // ... more generic, but less efficient algorithm
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \}
\par 
\par template <class RandomAccessIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 void evolve(RandomAccessIterator first, RandomAccessIterator last, \line 
random_access_iterator_tag) \{
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab // ... more efficient, but less generic algorithm
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \}
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285533}5.6.2 Library defined primitives}{\f9\fs20\cf1 {\*\bkmkend _Toc330285533}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
To simplify the task of defining the iterator_category, value_type and distance_type for user definable iterators, the library provides the following predefined classes and functions:
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 // iterator tags
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 
\par struct input_iterator_tag \{\};
\par struct output_iterator_tag \{\};
\par struct forward_iterator_tag \{\};
\par struct bidirectional_iterator_tag \{\};
\par struct random_access_iterator_tag \{\};
\par 
\par // iterator bases
\par 
\par template <class T, class Distance = ptrdiff_t> struct input_iterator \{\};
\par struct output_iterator \{\};
\par // output_iterator is not a template because output iterators
\par // do not have either value type or distance type defined.
\par template <class T, class Distance = ptrdiff_t> struct forward_iterator \{\};
\par template <class T, class Distance = ptrdiff_t> struct bidirectional_iterator \{\};
\par template <class T, class Distance = ptrdiff_t> struct random_access_iterator \{\};
\par 
\par // iterator_category
\par 
\par template <class T, class Distance> 
\par inline input_iterator_tag
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 iterator_category(const input_iterator<T, Distance>&) \{
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab return input_iterator_tag();
\par \}
\par inline output_iterator_tag iterator_category(const output_iterator&) \{
\par \tab return output_iterator_tag();
\par \}
\par template <class T, class Distance> 
\par inline forward_iterator_tag
\par iterator_category(const forward_iterator<T, Distance>&) \{
\par \tab return forward_iterator_tag();
\par \}
\par template <class T, class Distance> 
\par inline bidirectional_iterator_tag
\par iterator_category(const bidirectional_iterator<T, Distance>&) \{
\par \tab return bidirectional_iterator_tag();
\par \}
\par template <class T, class Distance> 
\par inline random_access_iterator_tag
\par iterator_category(const random_access_iterator<T, Distance>&) \{
\par \tab return random_access_iterator_tag();
\par \}
\par template <class T>
\par inline random_access_iterator_tag iterator_category(const T*) \{
\par \tab return random_access_iterator_tag();
\par \}
\par 
\par // value_type of iterator
\par 
\par template <class T, class Distance> 
\par inline T* value_type(const input_iterator<T, Distance>&) \{
\par \tab return (T*)(0); 
\par \}
\par template <class T, class Distance> 
\par inline T* value_type(const forward_iterator<T, Distance>&) \{
\par \tab return (T*)(0);
\par \}
\par template <class T, class Distance> 
\par inline T* value_type(const bidirectional_iterator<T, Distance>&) \{
\par \tab return (T*)(0);
\par \}
\par template <class T, class Distance> 
\par inline T* value_type(const random_access_iterator<T, Distance>&) \{
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab return (T*)(0);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \}
\par template <class T>
\par inline T* value_type(const T*) \{ return (T*)(0); \}
\par 
\par // distance_type of iterator
\par 
\par template <class T, class Distance> 
\par inline Distance* distance_type(const input_iterator<T, Distance>&) \{
\par \tab return (Distance*)(0);
\par \}
\par template <class T, class Distance> 
\par inline Distance* distance_type(const forward_iterator<T, Distance>&) \{
\par \tab return (Distance*)(0);
\par \}
\par template <class T, class Distance> 
\par inline Distance* distance_type(const bidirectional_iterator<T, Distance>&) \{
\par \tab return (Distance*)(0);
\par \}
\par template <class T, class Distance> 
\par inline Distance* distance_type(const random_access_iterator<T, Distance>&) \{
\par \tab return (Distance*)(0);
\par \}
\par template <class T>
\par inline ptrdiff_t* distance_type(const T*) \{ return (ptrdiff_t*)(0); \}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
If a user wants to define a bidirectional iterator for some data structure containing double and such that it works on a large memory model of a computer, it can be done by defining:
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 class MyIterator : public bidirectional_iterator<double, long> \{
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab // code implementing ++, etc.
\par \};
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 Then there is no need to define iterator_category, value_type, and distance_type on MyIterator.
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285534}5.7 Iterator operations}{\f9\fs22\cf1 {\*\bkmkend _Toc330285534}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 Since only rand
om access iterators provide + and - operators, the library provides two template functions advance and distance. These functions use + and - for random access iterators (and are, therefore, constant time for them); for input, forward and bidirectional ite
rators they use ++ to provide linear time implementations. advance takes a negative argument n for random access and bidirectional iterators only. advance increments (or decrements for negative n) iterator reference i by n. distance increments n by the nu
mber of times it takes to get from first to last. 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class InputIterator, class Distance>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 inline void advance(InputIterator& i, Distance n);
\par 
\par template <class InputIterator, class Distance>
\par inline void distance(InputIterator first, InputIterator last, Distance& n);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
distance must be a three argument function storing the result into a reference instead of returning the result because the distance type cannot be deduced from built-in iterator types such as int*.
\par }\pard\plain \s34\ri-548\sb320\sl280\slmult0\nowidctlpar \f8 {\b\f9\cf1 {\*\bkmkstart _Toc330285535}6  Function objects}{\f9\cf1 {\*\bkmkend _Toc330285535}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 Function objects are o
bjects with an operator() defined. They are important for the effective use of the library. In the places where one would expect to pass a pointer to a function to an algorithmic template, the interface is specified to accept an object with an operator() 
defined. This not only makes algorithmic templates work with pointers to functions, but also enables them to work with arbitrary function objects. Using function objects together with function templates increases the expressive power of the library as wel
l as making the resulting code much more efficient. For example, if we want to have a by-element addition of two vectors a and b containing double and put the result into a we can do:
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 transform(a.begin(), a.end(), b.begin(), a.begin(), plus<double>());
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 If we want to negate every element of a we can do:
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 transform(a.begin(), a.end(), a.begin(), negate<double>());
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 The corresponding functions will inline the addition and the negation.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 To enable adaptors and other components to manipulate function objects that t
ake one or two arguments it is required that they correspondingly provide typedefs argument_type and result_type for function objects that take one argument and first_argument_type, second_argument_type, and result_type for function objects that take two 
arguments.
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285536}6.1 Base}{\f9\fs22\cf1 {\*\bkmkend _Toc330285536}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 The following classes are provided to simplify the typedefs of the argument and result types:
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class Arg, class Result>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 struct unary_function \{
\par \tab typedef Arg argument_type;
\par \tab typedef Result result_type;
\par \};
\par 
\par template <class Arg1, class Arg2, class Result>
\par struct binary_function \{
\par \tab typedef Arg1 first_argument_type;
\par \tab typedef Arg2 second_argument_type;
\par \tab typedef Result result_type;
\par \};\tab 
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285537}6.2 Arithmetic operations}{\f9\fs22\cf1 {\*\bkmkend _Toc330285537}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 The library provides basic function object classes for all of the arithmetic operators in the language.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 struct plus : binary_function<T, T, T> \{
\par \tab T operator()(const T& x, const T& y) const \{ return x + y; \}
\par \};
\par 
\par template <class T>
\par struct minus : binary_function<T, T, T> \{
\par \tab T operator()(const T& x, const T& y) const \{ return x - y; \}
\par \};
\par 
\par template <class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 struct times : binary_function<T, T, T> \{
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab T operator()(const T& x, const T& y) const \{ return x * y; \}
\par \};
\par 
\par template <class T>
\par struct divides : binary_function<T, T, T> \{
\par \tab T operator()(const T& x, const T& y) const \{ return x / y; \}
\par \};
\par 
\par template <class T>
\par struct modulus : binary_function<T, T, T> \{
\par \tab T operator()(const T& x, const T& y) const \{ return x % y; \}
\par \};
\par 
\par template <class T>
\par struct negate : unary_function<T, T> \{
\par \tab T operator()(const T& x) const \{ return -x; \}
\par \};
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285538}6.3 Comparisons}{\f9\fs22\cf1 {\*\bkmkend _Toc330285538}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 The library provides basic function object classes for all of the comparison operators in the language.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 struct equal_to : binary_function<T, T, bool> \{
\par \tab bool operator()(const T& x, const T& y) const \{ return x == y; \}
\par \};
\par 
\par template <class T>
\par struct not_equal_to : binary_function<T, T, bool> \{
\par \tab bool operator()(const T& x, const T& y) const \{ return x != y; \}
\par \};
\par 
\par template <class T>
\par struct greater : binary_function<T, T, bool> \{
\par \tab bool operator()(const T& x, const T& y) const \{ return x > y; \}
\par \};
\par 
\par template <class T>
\par struct less : binary_function<T, T, bool> \{
\par \tab bool operator()(const T& x, const T& y) const \{ return x < y; \}
\par \};
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 template <class T>
\par struct greater_equal : binary_function<T, T, bool> \{
\par \tab bool operator()(const T& x, const T& y) const \{ return x >= y; \}
\par \};
\par 
\par template <class T>
\par struct less_equal : binary_function<T, T, bool> \{
\par \tab bool operator()(const T& x, const T& y) const \{ return x <= y; \}
\par \};
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285539}6.4 Logical operations}{\f9\fs22\cf1 {\*\bkmkend _Toc330285539}
\par }\pard \s37\ri-548\sb200\sl260\slmult0\nowidctlpar {\f9\fs22\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 struct logical_and : binary_function<T, T, bool> \{
\par \tab bool operator()(const T& x, const T& y) const \{ return x && y; \}
\par \};
\par 
\par template <class T>
\par struct logical_or : binary_function<T, T, bool> \{
\par \tab bool operator()(const T& x, const T& y) const \{ return x || y; \}
\par \};
\par 
\par template <class T>
\par struct logical_not : unary_function<T, bool> \{
\par \tab bool operator()(const T& x) const \{ return !x; \}
\par \};
\par }\pard\plain \s34\ri-548\sb320\sl280\slmult0\nowidctlpar \f8 {\b\f9\cf1 {\*\bkmkstart _Toc330285540}7  Allocators}{\f9\cf1 {\*\bkmkend _Toc330285540}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 One of the common problems in portability is to be able to encapsulate the information about the memory model. This information includes the knowl
edge of pointer types, the type of their difference, the type of the size of objects in this memory model, as well as the memory allocation and deallocation primitives for it.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
STL addresses this problem by providing a standard set of requirements for allocators, which are objects that encapsulate this information. All of the containers in STL are parameterized in terms of allocators. That dramatically simplifies the task of dea
ling with multiple memory models.
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285541}7.1 Allocator requirements}{\f9\fs22\cf1 {\*\bkmkend _Toc330285541}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 In the following tab
le, we assume X is an allocator class for objects of type T, a is a value of X, n is of type X::size_type, p is of type X::pointer, r is of type X::reference and s is of type X::const_reference. 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 All the operations on the allocators are expected to be amortized constant time.}{\b\f18\fs20\cf1 \tab }{\b\cf1 Table 7: Allocator requirements
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\cf1 
\par }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3960\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx6264\clbrdrt\brdrs\brdrw15 \clbrdrl
\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx11016 \pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 expression\cell }\pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 return type\cell }\pard \s17\qc\sl280\slmult0
\nowidctlpar\intbl {\fs20\cf1 assertion/note
\par }\pard\plain \s21\qj\sl280\slmult0\nowidctlpar\intbl \f8 {\fs20\cf1 pre/post-condition\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 
\cellx3960\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx6264\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx11016 \pard\plain \s21\qc\sl280\slmult0
\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X::value_type \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 T\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard\plain \widctlpar\intbl \f8 {\f3\fs18\cf1 \row 
}\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X::reference\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 lvalue of T\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 \cell }\pard\plain 
\widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X::const_reference\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 const lvalue of T\cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\fs20\cf1 \cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X::pointer\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 pointer to T type\cell 
}\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 the result of operator* of values of X::pointer is of reference.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 
X::const_pointer\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 pointer to const T type\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 the result of operator* of values of X::const_pointer is of const_reference;
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 it is the same type of pointer as X::pointer, in particu\-lar, sizeof(X::const_pointer) == sizeof(X::pointer).\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain 
\s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X::size_type\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 unsigned integral type\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 
the type that can represent the size of the largest object in the memory model.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X::difference_type\cell }\pard 
\s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 signed integral type\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 the type that can represent the difference between any two pointers in the memory model.\cell }\pard\plain 
\widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X a;\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 
note: a destructor is assumed.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.address(r)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 pointer\cell 
}\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 *(a.address(r)) == r.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.const_address(s)\cell }\pard 
\s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 const_pointer\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 *(a.address(s)) == s.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0
\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.allocate(n)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 X::pointer\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 
memory is allocated for n objects of type T but objects are not constructed. allocate may raise an appropriate exception.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 
a.deallocate(p)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 result is not used\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 
all the objects in the area pointed by p should be destroyed prior to the call of the deallocate.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 construct(p, a)\cell }\pard 
\s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 void\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 post: *p == a.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {
\f3\fs18\cf1 destroy(p)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 void\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 the value pointed by p is destroyed.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row 
}\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.init_page_size()\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 X::size_type\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 
the returned value is the optimal value for an initial buffer size of the given type. It is assumed that if k is returned by init_page_size, t is the construction time for T, and u is the time that it takes to do allo\-
cate(k), then k * t is much greater than u.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3960\clbrdrt\brdrs\brdrw15 \clbrdrl
\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx6264\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx11016 \pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 
a.max_size()\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 X::size_type\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 the largest positive value of X::difference_type\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 
\row }\pard \qc\ri-548\sl280\slmult0\nowidctlpar {\fs20\cf1 
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\fs20\cf1 pointer belongs to the category of mutable random access iterators referring to T. const_pointer belongs to the category of constant random a
ccess iterators referring to T. There is a conversion defined from pointer to const_pointer.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\fs20\cf1 
For any allocator template Alloc there is a specialization for type void. Alloc<void> has only constructor, destructor, and Alloc<void>::pointer defined. Conversions are defined from any instance of Alloc<T>::pointer into Alloc<void>::pointer and back so 
that for any p, p == Alloc<T>::pointer(Alloc<void>::pointer(p)).
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285542}7.2 The default allocator}{\f9\fs22\cf1 {\*\bkmkend _Toc330285542}
\par }\pard \s37\ri-548\sb200\sl260\slmult0\nowidctlpar {\f9\fs22\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 class allocator \{
\par public:
\par \tab typedef T* pointer;
\par \tab typedef const T* const_pointer;
\par \tab typedef T& reference;
\par \tab typedef const T& const_reference;
\par \tab typedef T value_type;
\par \tab typedef size_t size_type;
\par \tab typedef ptrdiff_t difference_type;
\par \tab allocator();
\par \tab ~allocator();
\par \tab pointer address(reference x);
\par \tab const_pointer const_address(const_reference x);
\par \tab pointer allocate(size_type n);
\par \tab void deallocate(pointer p); 
\par \tab size_type init_page_size();
\par \tab size_type max_size();
\par \};
\par 
\par class allocator<void> \{
\par public:
\par \tab typedef void* pointer;
\par \tab allocator();
\par \tab ~allocator();
\par \};
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 In addition to allocator the library vendors are expected to provide allocators for all supported memory models.
\par }\pard\plain \s34\ri-548\sb320\sl280\slmult0\nowidctlpar \f8 {\b\f9\cf1 {\*\bkmkstart _Toc330285543}8  Containers}{\f9\cf1 {\*\bkmkend _Toc330285543}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 Containers are objects that store other objects. They control allocation and deallocation of these objects through constructors, destructors, insert and erase operations. 

\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 In the following table, we assume X is a container class containing objects of type T, a and b are values of X, u is an identifier and r is a value of X&.
\par }\pard \s17\qc\ri-548\sb140\sl280\slmult0\nowidctlpar {\b\cf1 Table 8: Container requirements
\par }\pard \s17\qc\ri-548\sb140\sl280\slmult0\nowidctlpar {\cf1 
\par }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3240\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx5400\clbrdrt\brdrs\brdrw15 \clbrdrl
\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx7416\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx10152\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr
\brdrs\brdrw15 \cellx11016 \pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 expression\cell return type\cell }\pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 operational semantics\cell }\pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {
\fs20\cf1 assertion/note
\par }\pard\plain \s21\qj\sl280\slmult0\nowidctlpar\intbl \f8 {\fs20\cf1 pre/post-condition\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 complexity\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\trowd \trqc \clbrdrt\brdrs\brdrw15 
\clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3240\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx5400\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 
\clbrdrr\brdrs\brdrw15 \cellx7416\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx10152\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx11016 \pard\plain 
\s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X::value_type\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 T\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 compile time\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X::reference\cell 
}\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {
\fs20\cf1 compile time\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X::const_reference\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard 
\s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 compile \line time\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 
\row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X::pointer\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 a pointer type pointing to X::reference\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 
\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 pointer to T in the memory model used by the container\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 compile time\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row 
}\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X::iterator\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 iterator type pointing to X::reference\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 \cell 
}\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 an iterator of any iterator cate\-gory except output iterator.\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 compile time\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row 
}\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X::const_iterator\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 iterator type pointing to \line X::const_reference\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl 
{\fs20\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 a constant iterator of any itera\-tor category except output itera\-tor.\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 compile \line time\cell }\pard\plain 
\widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X::difference_type\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 signed integral type\cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\fs20\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 is identical to the distance type of X::iterator and X::const_iterator\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 compile time\cell 
}\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X::
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 size_type\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 unsigned integral type\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 \cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\fs20\cf1 size_type can represent any non-negative value of difference_type\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 compile time\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain 
\s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X u;\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {
\fs20\cf1 post: u.size() == 0.\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 constant\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X()\cell }\pard 
\s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 X().size() == 0.\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {
\fs20\cf1 constant\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X(a)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 a == X(a).\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 linear \cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain 
\s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X u(a);
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 X u = a;\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 X u; u = a;\cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\fs20\cf1 post: u == a.\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 linear\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 (&a)->~X()
\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 result is not used\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 post: a.size() == 0.
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 note: the destructor is applied to every element of a and all the memory is returned.\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 linear\cell }\pard\plain \widctlpar\intbl \f8 {
\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.begin()\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 iterator; const_iterator for constant a\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {
\fs20\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 constant\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl 
\f8 {\f3\fs18\cf1 a.end()\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 iterator; const_iterator for constant a\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {
\fs20\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 constant\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a == b\cell }{\fs20\cf1 convertible to bool
\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 a.size() == b.size() && equal(a.begin(), a.end(), b.begin())\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 == is an equivalence relation.
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 note: equal is defined in the algorithms section.\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 linear\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain 
\s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a != b\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 convertible to bool\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 !(a == b)\cell }\pard 
\s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 linear\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 
r = a\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 X&\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 if (&r != &a) \{
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 (&r)->X::~X();
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 new (&r) X(a); 
\par return r; \}\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 post: r == a.\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 linear\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0
\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.size()\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 size_type\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 size_type n = 0;
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 distance
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 (a.begin(), a.end(), n);
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 return n;\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 constant\cell }\pard\plain \widctlpar\intbl \f8 {
\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.max_size()\cell }\pard \s21\qc\fi-1440\li720\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 size_type\cell }\pard \s21\qc\fi-1440\li720\sl280\slmult0\nowidctlpar\intbl 
{\f3\fs18\cf1 \cell }\pard \s21\qc\fi-1440\li720\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 size() of the largest possible container.\cell }\pard \s21\qc\fi-1440\li720\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 constant\cell }\pard\plain \widctlpar\intbl 
\f8 {\fs20\cf1 \row }\pard\plain \s21\qc\fi-1440\li720\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.empty()\cell }\pard \s21\qc\fi-1440\li720\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 convertible to bool\cell }\pard 
\s21\qc\fi-1440\li720\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 a.size() == 0\cell }\pard \s21\qc\fi-1440\li720\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 constant\cell }\pard\plain 
\widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a < b\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 convertible to bool\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {
\fs20\cf1 lexicographical_compare(a.begin(),a.end(), b.begin(), b.end())\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 pre: < is defined for values of T.
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 < is a total ordering relation. 
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 lexicographical_compare is defined in the algorithms sec\-tion.\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 linear\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row 
}\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a > b\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 convertible to bool\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 b < a\cell }\pard 
\s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 linear\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a <= b
\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 convertible to bool\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 !(a > b)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 \cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\fs20\cf1 linear\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a >= b\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 convertible to bool
\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 !(a < b)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 linear\cell }\pard\plain \widctlpar\intbl \f8 {
\fs20\cf1 \row }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3240\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx5400\clbrdrt
\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx7416\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx10152\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb
\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx11016 \pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.swap(b)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 void\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {
\f3\fs18\cf1 swap(a,b)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 constant\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard \qc\ri-548\sl280\slmult0
\nowidctlpar {\fs20\cf1 
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\fs20\cf1 The member function size() returns the number of elements in the container. Its semantics is defined by the rules of constructors, inserts, and erases.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\fs20\cf1 begin() returns an iterator referring to the first element in the container. end() returns an iterator which is the past-the-end value.
\par If the iterator type of a container belongs to the bidirectional or random access iterator categories, the container is called reversible and satisfies the following additional requirements: 
\par }\pard \s17\qc\ri-548\sb140\sl280\slmult0\nowidctlpar {\b\cf1 Table 9: Reversible container requirements (in addition to container)
\par }\pard \s17\qc\ri-548\sb140\sl280\slmult0\nowidctlpar {\cf1 
\par }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3240\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx5400\clbrdrt\brdrs\brdrw15 \clbrdrl
\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx10152\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx11016 \pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 expression\cell 
}\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\fs20\cf1 return type\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 operational semantics\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 complexity\cell 
}\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3240\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr
\brdrs\brdrw15 \cellx5400\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx10152\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx11016 \pard\plain 
\s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X::reverse_iterator\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 reverse_iterator<iterator, value_type, 

\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 reference, difference_type> 
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 for random access iterator
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 reverse_bidirectional_iterator<iterator, value_type, reference, difference_type>
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 for bidirectional iterator\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 compile \line time\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain 
\s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X::const_reverse_iterator\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 
reverse_iterator<const_iterator, value_type, const_reference, difference_type> 
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 for random access iterator
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 reverse_bidirectional_iterator<
\par const_iterator, value_type,
\par const_reference, difference_type>
\par }{\fs20\cf1 for bidirectional iterator\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 compile \line time\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 
a.rbegin()\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 reverse_iterator;
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 const_reverse_iterator for constant a\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 reverse_iterator(end())\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 
constant\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3240\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 
\clbrdrr\brdrs\brdrw15 \cellx5400\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx10152\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx11016 \pard\plain 
\s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.rend()\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 reverse_iterator;
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 const_reverse_iterator for constant a\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 reverse_iterator(begin())\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 
constant\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard \qc\ri-548\sl280\slmult0\nowidctlpar {\fs20\cf1 
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285544}8.1 Sequences}{\f9\fs22\cf1 {\*\bkmkend _Toc330285544}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 A sequence is a kind of container that organizes a finite set of objects, all of the same type, into a strictly linea
r arrangement. The library provides three basic kinds of sequence containers: vector, list, and deque. It also provides container adaptors that make it easy to construct abstract data types, such as stacks or queues, out of the basic sequence kinds (or ou
t of other kinds of sequences that the user might define).
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
In the following two tables, X is a sequence class, a is value of X, i and j satisfy input iterator requirements, [i, j) is a valid range, n is a value of X::size_type, p is a valid iterator to a, q
 is a dereferenceable iterator to a, [q1, q2) is a valid range in a, t is a value of X::value_type.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 The complexities of the expressions are sequence dependent.
\par }\pard \s17\qc\ri-548\sb140\sl280\slmult0\nowidctlpar {\b\cf1 Table 10: Sequence requirements (in addition to container)
\par }\pard \s17\qc\ri-548\sb140\sl280\slmult0\nowidctlpar {\cf1 
\par }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3960\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx5688\clbrdrt\brdrs\brdrw15 \clbrdrl
\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx10296 \pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 expression\cell }\pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 return type\cell }\pard \s17\qc\sl280\slmult0
\nowidctlpar\intbl {\fs20\cf1 assertion/note
\par }\pard\plain \s21\qj\sl280\slmult0\nowidctlpar\intbl \f8 {\fs20\cf1 pre/post-condition\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 
\cellx3960\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx5688\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx10296 \pard\plain \s21\qc\sl280\slmult0
\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X(n, t)
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 X a(n, t);\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 post: size() == n.
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 constructs a sequence with n copies of t.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X(i, j)
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 X a(i, j);\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 post: size() == distance between i and j.
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 constructs a sequence equal to the range [i, j).\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.insert(p, t)\cell 
}\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 iterator\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 inserts a copy of t before p.
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 the return value points to the inserted copy.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.insert(p, n, t)\cell 
}\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 result is not used\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 inserts n copies of t before p.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain 
\s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.insert(p, i, j)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 result is not used\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 
inserts copies of elements in [i, j) before p.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.erase(q)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 
result is not used\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 erases the element pointed to by q.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb
\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3960\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx5688\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx10296 
\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.erase(q1, q2)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 result is not used\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 
erases the elements in the range [q1, q2).\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard \qc\ri-548\sl280\slmult0\nowidctlpar {\fs20\cf1 
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\fs20\cf1 vector, list, and deque offer the programmer different complexity trade-offs and should be used accordingly. vector is the type of sequence that shou
ld be used by default. list should be used when there are frequent insertions and deletions from the middle of the sequence. deque is the data structure of choice when most insertions and deletions take place at the beginning or at the end of the sequence
.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\fs20\cf1 iterator and const_iterator types for sequences have to be at least of the forward iterator category.
\par }\pard \s17\qc\ri-548\sb140\sl280\slmult0\nowidctlpar {\b\cf1 Table 11: Optional sequence operations
\par }\pard \s17\qc\ri-548\sb140\sl280\slmult0\nowidctlpar {\cf1 
\par }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3672\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx5976\clbrdrt\brdrs\brdrw15 \clbrdrl
\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx8712\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx10872 \pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 expression\cell 
}\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\fs20\cf1 return type\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 operational semantics\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 container\cell 
}\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3672\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr
\brdrs\brdrw15 \cellx5976\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx8712\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx10872 \pard\plain 
\s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.front()\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 reference;
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 const_reference for constant a\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 *a.begin()\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 vector, list, deque\cell 
}\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.back()\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 reference;
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 const_reference for constant a\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 *a.(--end())\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 vector, list, deque
\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.push_front(t)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 void\cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\f3\fs18\cf1 a.insert(a.begin(), t)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 list, deque\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {
\f3\fs18\cf1 a.push_back(t)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 void\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 a.insert(a.end(), t)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 
vector, list, deque\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.pop_front()\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 void\cell }\pard 
\s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 a.erase(a.begin())\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 list, deque\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0
\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.pop_back()\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 void\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 a.erase(--a.end())\cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\fs20\cf1 vector, list, deque\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3672\clbrdrt\brdrs\brdrw15 \clbrdrl
\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx5976\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx8712\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr
\brdrs\brdrw15 \cellx10872 \pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a[n]\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 reference;
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 const_reference for constant a\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 *(a.begin() + n)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 vector, deque\cell 
}\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard \qc\ri-548\sl280\slmult0\nowidctlpar {\fs20\cf1 
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\fs20\cf1 All the operations in the above table are provided only for the containers for which they take constant time.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285545}8.1.1 Vector}{\f9\fs20\cf1 {\*\bkmkend _Toc330285545}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
vector is a kind of sequence that supports random access iterators. In addition, it supports (amortized) constant time insert and erase operations at the end; insert and erase in the middle take linear time. Storage management is handled automatically, th
ough hints can be given to improve efficiency.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class T, template <class U> class Allocator = allocator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 class vector \{
\par public:
\par 
\par // typedefs:
\par 
\par \tab typedef iterator; 
\par \tab typedef const_iterator; 
\par \tab typedef Allocator<T>::pointer pointer;
\par \tab typedef Allocator<T>::reference reference;
\par \tab typedef Allocator<T>::const_reference const_reference;
\par \tab typedef size_type;
\par \tab typedef difference_type;
\par \tab typedef T value_type;
\par \tab typedef reverse_iterator;
\par \tab typedef const_reverse_iterator;
\par 
\par // allocation/deallocation:
\par 
\par \tab vector();
\par \tab vector(size_type n, const T& value = T());
\par \tab vector(const vector<T, Allocator>& x); 
\par \tab template <class InputIterator>
\par \tab vector(InputIterator first, InputIterator last);
\par \tab ~vector();
\par \tab vector<T, Allocator>& operator=(const vector<T, Allocator>& x);
\par \tab void reserve(size_type n);
\par \tab void swap(vector<T, Allocator>& x);
\par 
\par // accessors:
\par 
\par \tab iterator begin();
\par \tab const_iterator begin() const;
\par \tab iterator end();
\par \tab const_iterator end() const;
\par \tab reverse_iterator rbegin();
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab const_reverse_iterator rbegin();
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab reverse_iterator rend();
\par \tab const_reverse_iterator rend();
\par \tab size_type size() const;
\par \tab size_type max_size() const;
\par \tab size_type capacity() const;
\par \tab bool empty() const;
\par \tab reference operator[](size_type n);
\par \tab const_reference operator[](size_type n) const;
\par \tab reference front();
\par \tab const_reference front() const;
\par \tab reference back(); 
\par \tab const_reference back() const; 
\par 
\par // insert/erase:
\par 
\par \tab void push_back(const T& x);
\par \tab iterator insert(iterator position, const T& x = T());
\par \tab void insert(iterator position, size_type n, const T& x);
\par \tab template <class InputIterator> 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab void insert(iterator position, InputIterator first, InputIterator last);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab void pop_back();
\par \tab void erase(iterator position);
\par \tab void erase(iterator first, iterator last);
\par \};
\par 
\par template <class T, class Allocator>
\par bool operator==(const vector<T, Allocator>& x, const vector<T, Allocator>& y);
\par 
\par template <class T, class Allocator>
\par bool operator<(const vector<T, Allocator>& x, const vector<T, Allocator>& y);
\par \tab 
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 iterator is a random access iterator \tab referring to T. The exact type is implementation dependent and determined by Allocator. \tab 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 const_iterator is a constant random access iterator referring to const T.\tab  The exact type is implementation dependent and determined by Allocator. I
t is guaranteed that there is a constructor for const_iterator out of iterator.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 \tab \tab size_type is an unsigned integral type. The exact type is implementation dependent and determined by Allocator.
\par \tab difference_type is a signed integral type. The exact type is implementation dependent and determined by Allocator.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 The constructor template <class InputIterator> \tab 
vector(InputIterator first, InputIterator last) makes only N calls to the copy constructor of T (where N is the distance between first and last) and no re
allocations if iterators first and last are of forward, bidirectional, or random access categories. It does at most 2N calls to the copy constructor of T and logN reallocations if they are just input iterators, since it is impossible to determine the dist
ance between first and last and then do copying.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
The member function capacity returns the size of the allocated storage in the vector. The member function reserve is a directive that informs vector of a planned change in size, so that it can manage the stor
age allocation accordingly. It does not change the size of the sequence and takes at most linear time in the size of the sequence. Reallocation happens at this point if and only if the current capacity is less than the argument of reserve. After reserve, 
capacity is greater or equal to the argument of reserve if reallocation happens; and equal to the previous value of capacity otherwise. Reallocation invalidates all the references, pointers, and iterators referring to the elements in the sequence. It is g
uaranteed that no reallocation takes place during the insertions that happen after reserve takes place till the time when the size of the vector reaches the size specified by reserve.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
insert causes reallocation if the new size is greater than the old capacity. If no reallocation happens, all the iterators and references before the insertion point remain valid. Inserting a single element into a vector is linear in the distance from the 
insertion point to the end of the vector. The amortized complexity over the
 lifetime of a vector of inserting a single element at its end is constant. Insertion of multiple elements into a vector with a single call of the insert member function is linear in the sum of the number of elements plus the distance to the end of the ve
ctor. In other words, it is much faster to insert many elements into the middle of a vector at once than to do the insertion one at a time. The insert template member function preallocates enough storage for the insertion if the iterators first and last a
re of forward, bidirectional or random access category. Otherwise, it does insert elements one by one and should not be used for inserting into the middle of vectors. 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
erase invalidates all the iterators and references after the point of the erase. The destructor of T is called the number of times equal to the number of the elements erased, but the assignment operator of T is called the number of times equal to the numb
er of elements in the vector after the erased elements. 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 To optimize space allocation, a specialization for bool is provided:
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 class vector<bool, allocator> \{
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 public:
\par 
\par // bit reference:
\par 
\par \tab class reference \{
\par \tab public:
\par       \tab \tab ~reference();
\par        \tab \tab operator bool() const;
\par        \tab \tab reference& operator=(const bool x);
\par        \tab \tab void flip();\tab \tab \tab // flips the bit
\par \tab \};
\par 
\par // typedefs:
\par 
\par \tab typedef bool const_reference;
\par \tab typedef iterator; 
\par \tab typedef const_iterator; 
\par \tab typedef size_t size_type;
\par \tab typedef ptrdiff_t difference_type;
\par \tab typedef bool value_type;
\par \tab typedef reverse_iterator;
\par \tab typedef const_reverse_iterator;
\par 
\par // allocation/deallocation:
\par 
\par \tab vector();
\par \tab vector(size_type n, const bool& value = bool());
\par \tab vector(const vector<bool, allocator>& x); 
\par \tab template <class InputIterator>
\par \tab vector(InputIterator first, InputIterator last);
\par \tab ~vector();
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab vector<bool, allocator>& operator=(const vector<bool, allocator>& x);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab void reserve(size_type n);
\par \tab void swap(vector<bool, allocator>& x);
\par 
\par // accessors:
\par 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab iterator begin();
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab const_iterator begin() const;
\par \tab iterator end();
\par \tab const_iterator end() const;
\par \tab reverse_iterator rbegin();
\par \tab const_reverse_iterator rbegin();
\par \tab reverse_iterator rend();
\par \tab const_reverse_iterator rend();
\par \tab size_type size() const;
\par \tab size_type max_size() const;
\par \tab size_type capacity() const;
\par \tab bool empty() const;
\par \tab reference operator[](size_type n);
\par \tab const_reference operator[](size_type n) const;
\par \tab reference front();
\par \tab const_reference front() const;
\par \tab reference back(); 
\par \tab const_reference back() const; 
\par 
\par // insert/erase:
\par 
\par \tab void push_back(const bool& x);
\par \tab iterator insert(iterator position, const bool& x = bool());
\par \tab void insert (iterator position, size_type n, const bool& x);
\par \tab template <class InputIterator> 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab void insert (iterator position, InputIterator first, InputIterator last);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab void pop_back();
\par \tab void erase(iterator position);
\par \tab void erase(iterator first, iterator last);
\par \};
\par 
\par void swap(vector<bool, allocator>::reference x, 
\par \tab  vector<bool, allocator>::reference y);
\par 
\par bool operator==(const vector<bool, allocator>& x, 
\par \tab \tab const vector<bool, allocator>& y);
\par 
\par bool operator<(const vector<bool, allocator>& x, 
\par \tab \tab const vector<bool, allocator>& y);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 reference is a class that simulates the behavior of references of a single bit in vector<bool>.
\par Every implementation is expected to provide specializations of vector<bool> for all supported memory models.
\par }\pard \s17\sb140\sl280\slmult0\nowidctlpar\pvpg\phpg\posx532\posy144\absh2563\absw8280 {\f18\fs20\cf1 At present, it is not possible to templatize a specialization. That is, we cannot write:
\par }\pard \s17\sb140\sl280\slmult0\nowidctlpar\pvpg\phpg\posx532\posy144\absh2563\absw8280 {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\sl280\slmult0\nowidctlpar\pvpg\phpg\posx532\posy144\absh2563\absw8280 \f8 {\f3\fs18\cf1 template <template <class U> class Allocator = allocator>
\par }\pard \s32\fi-1440\li2160\sl280\slmult0\nowidctlpar\pvpg\phpg\posx532\posy144\absh2563\absw8280 {\f3\fs18\cf1 class vector<bool, Allocator> \{ /* ... */ \};
\par }\pard\plain \s17\qj\sb140\sl280\slmult0\nowidctlpar\pvpg\phpg\posx532\posy144\absh2563\absw8280 \f8 {\f18\fs20\cf1 Therefore, only vector<bool, allocator> is provided.
\par }\pard \s17\ri-548\sl260\slmult0\nowidctlpar {\i\f9\fs20\cf1 8.1.2 List}{\f9\fs20\cf1 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 list is a kind of sequence that supports bidirecti
onal iterators and allows constant time insert and erase operations anywhere within the sequence, with storage management handled automatically. Unlike vectors and deques, fast random access to list elements is not supported, but many algorithms only need
 sequential access anyway.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class T, template <class U> class Allocator = allocator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 class list \{
\par public:
\par 
\par // typedefs:
\par 
\par \tab typedef iterator; 
\par \tab typedef const_iterator; 
\par \tab typedef Allocator<T>::pointer pointer;
\par \tab typedef Allocator<T>::reference reference;
\par \tab typedef Allocator<T>::const_reference const_reference;
\par \tab typedef size_type;
\par \tab typedef difference_type;
\par \tab typedef T value_type;
\par \tab typedef reverse_iterator;
\par \tab typedef const_reverse_iterator;
\par 
\par // allocation/deallocation:
\par 
\par \tab list();
\par \tab list(size_type n, const T& value = T());
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab template <class InputIterator> 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab list(InputIterator first, InputIterator last); 
\par \tab list(const list<T, Allocator>& x);
\par \tab ~list(); 
\par \tab list<T, Allocator>& operator=(const list<T, Allocator>& x);
\par \tab void swap(list<T, Allocator>& x);
\par 
\par // accessors:
\par 
\par \tab iterator begin();
\par \tab const_iterator begin() const;
\par \tab iterator end();
\par \tab const_iterator end() const;
\par \tab reverse_iterator rbegin();
\par \tab const_reverse_iterator rbegin();
\par \tab reverse_iterator rend();
\par \tab const_reverse_iterator rend();
\par \tab bool empty() const; 
\par \tab size_type size() const;
\par \tab size_type max_size() const;
\par \tab reference front();
\par \tab const_reference front() const;
\par \tab reference back(); 
\par \tab const_reference back() const; 
\par 
\par // insert/erase:
\par \tab 
\par \tab void push_front(const T& x);
\par \tab void push_back(const T& x);
\par \tab iterator insert(iterator position, const T& x = T());
\par \tab void insert(iterator position, size_type n, const T& x);
\par \tab template <class InputIterator> 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab void insert(iterator position, InputIterator first, InputIterator last);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab void pop_front();
\par \tab void pop_back();
\par \tab void erase(iterator position);
\par \tab void erase(iterator first, iterator last);
\par 
\par // special mutative operations on list:
\par 
\par \tab void splice(iterator position, list<T, Allocator>& x);
\par \tab void splice(iterator position, list<T, Allocator>& x, iterator i);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab void splice(iterator position, list<T, Allocator>& x, iterator first,
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab \tab iterator last);
\par \tab void remove(const T& value);
\par \tab template <class Predicate> void remove_if(Predicate pred);
\par \tab void unique();
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab template <class BinaryPredicate> void unique(BinaryPredicate binary_pred);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab void merge(list<T, Allocator>& x);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab template <class Compare> void merge(list<T, Allocator>& x, Compare comp);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab void reverse();
\par \tab void sort();
\par \tab template <class Compare> void sort(Compare comp);
\par \};
\par 
\par template <class T, class Allocator>
\par bool operator==(const list<T, Allocator>& x, const list<T, Allocator>& y);
\par 
\par template <class T, class Allocator>
\par bool operator<(const list<T, Allocator>& x, const list<T, Allocator>& y);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 iterator is a bidirectional iterator \tab referring to T. The exact type is implementation dependent and determined by Allocator. \tab \tab 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 const_iterator is a constant bidirectional iterator referring to const T.\tab 
 The exact type is implementation dependent and determined by Allocator. It is guaranteed that there is a constructor for const_iterator out of iterator.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 \tab \tab size_type is an unsigned integral type. The exact type is implementation dependent and determined by Allocator.
\par \tab difference_type is a signed integral type. The exact type is implementation dependent and determined by Allocator.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
insert does not affect the validity of iterators and references. Insertion of a single element into a list takes constant time and exactly one call to the copy constructor of T. Insertion of multiple elements into a list is linear in the number of element
s inserted, and the number of calls to the copy constructor of T is exactly equal to the number of elements inserted. 
\par erase invalidates only the iterators and references to the erased elements. Erasing a single element is a constant time operation with a single call to the destructor of T. Erasing a range in a list is linear time in the size of the range and the number o
f calls to the destructor of type T is exactly equal to the size of the range.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 Since lists allow fast insertion and erasing from the middle of a list, certain operations are provided specifically for them:
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 list provides three splice operations that destructively move elements from one list to another:
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 void splice(iterator position, list<T, Allocator>& x) inserts the contents of x before position and x becomes empty. It takes constant time. The result is undefined if &x == this.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 \tab 
void splice(iterator position, list<T, Allocator>& x, iterator i) inserts an element pointed to by i from list x before position and removes the element from x. It takes constant time. i is a valid dereferenceable iterat
or of x. The result is unchanged if position == i or position == ++i.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 void splice(iterator position, list<T, Allocator>& x, iterator first, \tab \tab \tab 
iterator last) inserts elements in the range [first, last) before position and removes the elements from x. It takes constant time if &x == this; otherwise, it takes linear time. [fi
rst, last) is a valid range in x. The result is undefined if position is an iterator in the range [first, last).
\par remove erases all the elements in the list referred by the list iterator i
 for which the following conditions hold: *i == value, pred(*i) == true. remove is stable, that is, the relative order of the elements that are not removed is the same as their relative order in the original list. Exactly size() applications of the corres
ponding predicate are done. 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 unique erases all but the first element from every consecutive group of equal elements in the list. Exactly size() - 1 applications of the corresponding binary predicate are done.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 merge merges the argument list into the list (bo
th are assumed to be sorted). The merge is stable, that is, for equal elements in the two lists, the elements from the list always precede the elements from the argument list. x is empty after the merge. At most size() + x.size() - 1 comparisons are done.

\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 reverse reverses the order of the elements in the list. It is linear time.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 sort sorts the list according to the operator< or a compare function object. It is stable, that is, the relative order of the equal elements is preserved. Approximately NlogN compar
isons are done where N is equal to size().
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285546}8.1.3 Deque}{\f9\fs20\cf1 {\*\bkmkend _Toc330285546}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
deque is a kind of sequence that, like a vector, supports random access iterators. In addition, it supports constant time insert and erase operations at the beginning or the end; insert and erase in the middle take linear time. As with vectors, storage ma
nagement is handled automatically.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class T, template <class U> class Allocator = allocator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 class deque \{
\par public:
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 // typedefs:
\par 
\par \tab typedef iterator; 
\par \tab typedef const_iterator; 
\par \tab typedef Allocator<T>::pointer pointer;
\par \tab typedef Allocator<T>::reference reference;
\par \tab typedef Allocator<T>::const_reference const_reference;
\par \tab typedef size_type;
\par \tab typedef difference_type;
\par \tab typedef T value_type;
\par \tab typedef reverse_iterator;
\par \tab typedef const_reverse_iterator;
\par 
\par // allocation/deallocation:
\par 
\par \tab deque();
\par \tab deque(size_type n, const T& value = T());
\par \tab deque(const deque<T, Allocator>& x); 
\par \tab template <class InputIterator>
\par \tab deque(InputIterator first, InputIterator last);
\par \tab ~deque();
\par \tab deque<T, Allocator>& operator=(const deque<T, Allocator>& x);
\par \tab void swap(deque<T, Allocator>& x);
\par 
\par // accessors:
\par 
\par \tab iterator begin();
\par \tab const_iterator begin() const;
\par \tab iterator end();
\par \tab const_iterator end() const;
\par \tab reverse_iterator rbegin();
\par \tab const_reverse_iterator rbegin();
\par \tab reverse_iterator rend();
\par \tab const_reverse_iterator rend();
\par \tab size_type size() const;
\par \tab size_type max_size() const;
\par \tab bool empty() const;
\par \tab reference operator[](size_type n);
\par \tab const_reference operator[](size_type n) const;
\par \tab reference front();
\par \tab const_reference front() const;
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab reference back(); 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab const_reference back() const; 
\par 
\par // insert/erase:
\par 
\par \tab void push_front(const T& x);
\par \tab void push_back(const T& x);
\par \tab iterator insert(iterator position, const T& x = T());
\par \tab void insert (iterator position, size_type n, const T& x);
\par \tab template <class InputIterator> 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab void insert (iterator position, InputIterator first, InputIterator last);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab void pop_front();
\par \tab void pop_back();
\par \tab void erase(iterator position);
\par \tab void erase(iterator first, iterator last);
\par \};
\par 
\par template <class T, class Allocator>
\par bool operator==(const deque<T, Allocator>& x, const deque<T, Allocator>& y);
\par 
\par template <class T, class Allocator>
\par bool operator<(const deque<T, Allocator>& x, const deque<T, Allocator>& y);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 iterator is a random access iterator referring to T. The exact type is implementation dependent and determined by Allocator. \tab 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 const_iterator is a constant random access iterator referring to const T.  
The exact type is implementation dependent and determined by Allocator. It is guaranteed that there is a constructor for const_iterator out of iterator.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 size_type is an unsigned integral type. The exact type is implementation dependent and determined by Allocator.
\par difference_type is a signed integral type. The exact type is implementation dependent and determined by Allocator.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
insert in the middle of a deque invalidates all the iterators and references to the deque. insert and push at either end of a deque invalidate all the iterators to the deque, but have no effect on the validity of all the references to the deque.  
In the worst case, inserting a single element into adeque takes time linear in the 
minimum of the distance from the insertion point to the beginning of the deque and the distance from the insertion point to the end of the deque. Inserting a single element either at the beginning or end of a deque always takes constant time and causes a 
single call to the copy constructor of T. That is, a deque is especially optimized for pushing and popping elements at the beginning and end.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 erase in the middle of a deque invalidates all the iterators and references to the dequ
e. erase and pop at either end of a deque invalidate only the iterators and the references to the erased element. The number of calls to the destructor is the same as the number of elements erased, but the number of the calls to the assignment operator is
 equal to the minimum of the number of elements before the erased elements and the number of element after the erased elements.
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285547}8.2 Associative containers}{\f9\fs22\cf1 {\*\bkmkend _Toc330285547}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 Associative containers provide an ability for fast retrieval of data based on keys. The library provid
es four basic kinds of associative containers: set, multiset, map and multimap.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
All of them are parameterized on Key and an ordering relation Compare that induces a total ordering on elements of Key. In addition, map and multimap associate an arbitrary type T with the Key. The object of type Compare is called the comparison object of
 a container.
\par In this section when we talk about equality of keys we mean the equivalence relation imposed by the comparison and not the operator== on keys. That is, two keys k1
 and k2 are considered to be equal if for the comparison object comp, comp(k1, k2) == false && comp(k2, k1) == false.
\par An associative container supports unique keys if it may contain at most one element for each key. Otherwise, it supports equal keys. set and map support unique keys. multiset and multimap support equal keys.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 For set and multiset the value type is the same as the key type. For map and multimap it is equal to pair<const Key, T>. 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 iterator of an associative container is of the bidirectional ite
rator category. insert does not affect the validity of iterators and references to the container, and erase invalidates only the iterators and references to the erased elements.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
In the following table, X is an associative container class, a is a value of X, a_uniq is a value of X when X supports unique keys, and a_eq is a value of X when X supports multiple keys, i and j satisfy input iterator requirements and refer to elements o
f value_type, [i, j) is a valid range, p is a valid iterator to a, q is a dereferenceable iterator to a, [q1, q2) is a valid range in a, t is a value of X::value_type and k is a value of X::key_type.
\par }\pard \s17\qc\ri-548\sb140\sl280\slmult0\nowidctlpar {\b\cf1 Table 12: Associative container requirements (in addition to container)
\par }\pard \s17\qc\ri-548\sb140\sl280\slmult0\nowidctlpar {\cf1 
\par }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3672\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx5544\clbrdrt\brdrs\brdrw15 \clbrdrl
\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx9144\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx11016 \pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 expression\cell 
}\pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 return type\cell }\pard \s17\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 assertion/note
\par }\pard\plain \s21\qj\sl280\slmult0\nowidctlpar\intbl \f8 {\fs20\cf1 pre/post-condition\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 complexity\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\trowd \trqc \clbrdrt\brdrs\brdrw15 
\clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3672\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx5544\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 
\clbrdrr\brdrs\brdrw15 \cellx9144\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx11016 \pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X::key_type\cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\f3\fs18\cf1 Key\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 compile time\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain 
\s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X::key_compare\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 Compare\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 defaults to less<key_type>.\cell }\pard 
\s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 compile time\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X::value_compare\cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\fs20\cf1 a binary predicate type\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 is the same as key_compare for set and multiset;
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 is an ordering relation on pairs induced by the first component (i.e. Key) for map and multimap.\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 compile time\cell }\pard\plain 
\widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X(c)
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 X a(c);\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 constructs an empty container;
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 uses c as a comparison object.\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 constant\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0
\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X()
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 X a;\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 constructs an empty container; 
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 uses Compare() as a comparison object.\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 constant\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain 
\s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X(i, j, c)
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 X a(i, j, c);\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 
constructs an empty container and inserts elements from the range [i, j) into it;
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 uses c as a comparison object.\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 NlogN in general (N is the distance from i to j);
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 linear if [i, j) is sorted with value_comp()\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 X(i, j)
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 X a(i, j);\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 same as above, but uses Compare(
) as a comparison object.\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 same as above\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.key_comp()\cell }\pard 
\s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 X::key_compare\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 returns the comparison object out of which a was constructed.\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {
\fs20\cf1 constant\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.value_comp()\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 X::value_compare\cell }\pard 
\s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 returns an object of value_compare constructed out of the comparison object.\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 constant\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row 
}\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a_uniq.insert(t)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 pair<iterator, bool>\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 
inserts t if and only if there is no element in the container with key equal to the key of t. The bool component of the returned pair indicates whether the insertion takes place and the iterator component of the pa
ir points to the element with key equal to the key of t.\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 logarithmic\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {
\f3\fs18\cf1 a_eq.insert(t)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 iterator\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 inserts t and returns the iterator pointing to the newly inserted element.\cell }\pard 
\s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 logarithmic\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.insert(p, t)\cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\f3\fs18\cf1 iterator\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 
inserts t if and only if there is no element with key equal to the key of t in containers with unique keys; always inserts t in containers with equal keys.
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 always returns the iterator pointing to the element with key equal to the key of t.
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 iterator p is a hint pointing to where the insert should start to search.\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 
logarithmic in general, but amortized constant if t is inserted right before p.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.insert(i, j)\cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\fs20\cf1 result is not used
\par \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 inserts the elements from the range [i, j) into the container.\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 
Nlog(size()+N) (N is the distance from i to j) in general; linear if [i, j) is sorted according to value_comp()\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.erase(k)\cell 
}\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 size_type\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 erases all the elements in the container with key equal to k.
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 returns the number of erased elements.\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 log(size()) + count(k)\cell }\pard\plain \widctlpar\intbl \f8 {\f3\fs18\cf1 \row 
}\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.erase(q)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 result is not used\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 
erases the element pointed to by q.\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 amortized constant\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 
a.erase(q1, q2)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 result is not used\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 erases all the elements in the range [q1, q2).\cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\fs20\cf1 log(size())+ N where N is the distance from q1 to q2.\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.find(k)\cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\f3\fs18\cf1 iterator;
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 const_iterator for constant a\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 
returns an iterator pointing to an element with the key equal to k, or a.end() if such an element is not found. \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 logarithmic\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row 
}\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.count(k)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 size_type\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 
returns the number of elements with key equal to k.\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 log(size())+ count(k)\cell }\pard\plain \widctlpar\intbl \f8 {\f3\fs18\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 
{\f3\fs18\cf1 a.lower_bound(k)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 iterator;
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 const_iterator for constant a\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 returns an iterator pointing to the first element with key not less than k.\cell }\pard 
\s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 logarithmic\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.upper_bound(k)\cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\fs20\cf1 iterator; const_iterator for constant a\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 returns an iterator pointing to the first element with key greater than k.\cell }\pard \s21\qc\sl280\slmult0
\nowidctlpar\intbl {\fs20\cf1 logarithmic\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3672\clbrdrt\brdrs\brdrw15 \clbrdrl
\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx5544\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx9144\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr
\brdrs\brdrw15 \cellx11016 \pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl \f8 {\f3\fs18\cf1 a.equal_range(k)\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 pair<iterator, iterator>;
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\f3\fs18\cf1 pair<const_iterator, const_iterator>
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 for constant a\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 equivalent to make_pair(a.lower_bound(k), a.upper_bound(k)).\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {
\fs20\cf1 logarithmic\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard \qc\ri-548\sl280\slmult0\nowidctlpar {\fs20\cf1 
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\fs20\cf1 The fundamental property of iterators of associative containers is that they iterate through the containers in the non-descending orde
r of keys where non-descending is defined by the comparison that was used to construct them. For any two dereferenceable iterators i and j such that distance from i to j is positive, 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 value_comp(*j, *i) == false
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 For associative containers with unique keys the stronger condition holds,
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 value_comp(*i, *j) == true.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285548}8.2.1 Set}{\f9\fs20\cf1 {\*\bkmkend _Toc330285548}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 set is a kind of associative container that supports unique keys (contains at most one of each key value) and provides for fast retrieval of the keys themselves.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class Key, class Compare = less<Key>, 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab template <class U> class Allocator = allocator>
\par class set \{
\par public:
\par 
\par // typedefs:
\par 
\par \tab typedef Key key_type;
\par \tab typedef Key value_type;
\par \tab typedef Allocator<Key>::pointer pointer;
\par \tab typedef Allocator<Key>::reference reference;
\par \tab typedef Allocator<Key>::const_reference const_reference;
\par \tab typedef Compare key_compare;
\par \tab typedef Compare value_compare;
\par \tab typedef iterator; 
\par \tab typedef iterator const_iterator;
\par \tab typedef size_type;
\par \tab typedef difference_type;
\par \tab typedef reverse_iterator;
\par \tab typedef const_reverse_iterator;
\par 
\par // allocation/deallocation:
\par 
\par \tab set(const Compare& comp = Compare());
\par \tab template <class InputIterator> 
\par \tab set(InputIterator first, InputIterator last,
\par \tab \tab const Compare& comp = Compare()); 
\par \tab set(const set<Key, Compare, Allocator>& x);
\par \tab ~set(); 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 \tab set<Key, Compare, Allocator>& operator=(const set<Key, Compare, Allocator>& x);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab void swap(set<Key, Compare, Allocator>& x);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 
\par // accessors:
\par 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab key_compare key_comp() const;
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab value_compare value_comp() const;
\par \tab iterator begin() const;
\par \tab iterator end() const;
\par \tab reverse_iterator rbegin() const;
\par \tab reverse_iterator rend() const;
\par \tab bool empty() const; 
\par \tab size_type size() const;
\par \tab size_type max_size() const;
\par 
\par // insert/erase:
\par 
\par \tab pair<iterator, bool> insert(const value_type& x);
\par \tab iterator insert(iterator position, const value_type& x);
\par \tab template <class InputIterator> 
\par \tab void insert(InputIterator first, InputIterator last);
\par \tab void erase(iterator position);
\par \tab size_type erase(const key_type& x);
\par \tab void erase(iterator first, iterator last);
\par 
\par // set operations:
\par 
\par \tab iterator find(const key_type& x) const;
\par \tab size_type count(const key_type& x) const;
\par \tab iterator lower_bound(const key_type& x) const;
\par \tab iterator upper_bound(const key_type& x) const;
\par \tab pair<iterator, iterator> equal_range(const key_type& x) const;
\par \};
\par 
\par template <class Key, class Compare, class Allocator>
\par bool operator==(const set<Key, Compare, Allocator>& x,
\par \tab \tab const set<Key, Compare, Allocator>& y);
\par 
\par template <class Key, class Compare, class Allocator>
\par bool operator<(const set<Key, Compare, Allocator>& x,
\par \tab \tab const set<Key, Compare, Allocator>& y);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 iterator is a constant bidirectional iterator referring to const value_type. The exact type is implementation dependent and determined by Allocator.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 const_iterator is the same type as iterator.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 \tab \tab size_type is an unsigned integral type. The exact type is implementation dependent and determined by Allocator.
\par \tab difference_type is a signed integral type. The exact type is implementation dependent and determined by Allocator.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285549}8.2.2 Multiset}{\f9\fs20\cf1 {\*\bkmkend _Toc330285549}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 multiset is a kind of associative container that supports 
equal keys (possibly contains multiple copies of the same key value) and provides for fast retrieval of the keys themselves.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class Key, class Compare = less<Key>,
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab template <class U> class Allocator = allocator>
\par class multiset \{
\par public:
\par 
\par // typedefs:
\par 
\par \tab typedef Key key_type;
\par \tab typedef Key value_type;
\par \tab typedef Allocator<Key>::pointer pointer;
\par \tab typedef Allocator<Key>::reference reference;
\par \tab typedef Allocator<Key>::const_reference const_reference;
\par \tab typedef Compare key_compare;
\par \tab typedef Compare value_compare;
\par \tab typedef iterator; 
\par \tab typedef iterator const_iterator;
\par \tab typedef size_type;
\par \tab typedef difference_type;
\par \tab typedef reverse_iterator;
\par \tab typedef const_reverse_iterator;
\par 
\par // allocation/deallocation:
\par 
\par \tab multiset(const Compare& comp = Compare());
\par \tab template <class InputIterator> 
\par \tab multiset(InputIterator first, InputIterator last,
\par \tab \tab const Compare& comp = Compare()); 
\par \tab multiset(const multiset<Key, Compare, Allocator>& x);
\par \tab ~multiset(); 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 \tab multiset<Key, Compare, Allocator>& operator=(const multiset<Key, Compare, Allocator>& x);

\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab void swap(multiset<Key, Compare, Allocator>& x);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 
\par // accessors:
\par 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab key_compare key_comp() const;
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab value_compare value_comp() const;
\par \tab iterator begin() const;
\par \tab iterator end() const;
\par \tab reverse_iterator rbegin();
\par \tab reverse_iterator rend();
\par \tab bool empty() const; 
\par \tab size_type size() const;
\par \tab size_type max_size() const;
\par 
\par // insert/erase:
\par 
\par \tab iterator insert(const value_type& x);
\par \tab iterator insert(iterator position, const value_type& x);
\par \tab template <class InputIterator> 
\par \tab void insert(InputIterator first, InputIterator last);
\par \tab void erase(iterator position);
\par \tab size_type erase(const key_type& x);
\par \tab void erase(iterator first, iterator last);
\par 
\par // multiset operations:
\par 
\par \tab iterator find(const key_type& x) const;
\par \tab size_type count(const key_type& x) const;
\par \tab iterator lower_bound(const key_type& x) const;
\par \tab iterator upper_bound(const key_type& x) const;
\par \tab pair<iterator, iterator> equal_range(const key_type& x) const;
\par \};
\par 
\par template <class Key, class Compare, class Allocator>
\par bool operator==(const multiset<Key, Compare, Allocator>& x,
\par \tab \tab const multiset<Key, Compare, Allocator>& y);
\par 
\par template <class Key, class Compare, class Allocator>
\par bool operator<(const multiset<Key, Compare, Allocator>& x,
\par \tab \tab const multiset<Key, Compare, Allocator>& y);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 iterator is a constant bidirectional iterator referring to const value_type. The exact type is implementation dependent and determined by Allocator.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 const_iterator is the same type as iterator.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 \tab \tab size_type is an unsigned integral type. The exact type is implementation dependent and determined by Allocator.
\par \tab difference_type is a signed integral type. The exact type is implementation dependent and determined by Allocator.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285550}8.2.3 Map}{\f9\fs20\cf1 {\*\bkmkend _Toc330285550}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
map is a kind of associative container that supports unique keys (contains at most one of each key value) and provides for fast retrieval of values of another type T based on the keys.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class Key, class T, class Compare = less<Key>,
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab template <class U> class Allocator = allocator>
\par class map \{
\par public:
\par 
\par // typedefs:
\par 
\par \tab typedef Key key_type;
\par \tab typedef pair<const Key, T> value_type;
\par \tab typedef Compare key_compare;
\par \tab class value_compare 
\par \tab \tab : public binary_function<\tab value_type, value_type, bool> \{
\par \tab friend class map;
\par \tab protected:
\par \tab \tab Compare comp;
\par \tab \tab value_compare(Compare c) : comp(c) \{\}
\par \tab public:
\par \tab \tab bool operator()(const value_type& x, const value_type& y) \{
\par \tab \tab \tab return comp(x.first, y.first);
\par \tab \tab \}
\par \tab \};
\par \tab typedef iterator; 
\par \tab typedef const_iterator; 
\par \tab typedef Allocator<value_type>::pointer pointer;
\par \tab typedef Allocator<value_type>::reference reference;
\par \tab typedef Allocator<value_type>::const_reference const_reference;
\par \tab typedef size_type;
\par \tab typedef difference_type;
\par \tab typedef reverse_iterator;
\par \tab typedef const_reverse_iterator;
\par 
\par // allocation/deallocation:
\par 
\par \tab map(const Compare& comp = Compare());
\par \tab template <class InputIterator> 
\par \tab map(InputIterator first, InputIterator last,
\par \tab \tab const Compare& comp = Compare()); 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab map(const map<Key, T, Compare, Allocator>& x);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab ~map(); 
\par \tab map<Key, T, Compare, Allocator>&
\par \tab \tab operator=(const map<Key, T, Compare, Allocator>& x);
\par \tab void swap(map<Key, T, Compare, Allocator>& x);
\par 
\par // accessors:
\par 
\par \tab key_compare key_comp() const;
\par \tab value_compare value_comp() const;
\par \tab iterator begin();
\par \tab const_iterator begin() const;
\par \tab iterator end();
\par \tab const_iterator end() const;
\par \tab reverse_iterator rbegin();
\par \tab const_reverse_iterator rbegin();
\par \tab reverse_iterator rend();
\par \tab const_reverse_iterator rend();
\par \tab bool empty() const; 
\par \tab size_type size() const;
\par \tab size_type max_size() const;
\par \tab Allocator<T>::reference operator[](const key_type& x);
\par 
\par // insert/erase:
\par 
\par \tab pair<iterator, bool> insert(const value_type& x);
\par \tab iterator insert(iterator position, const value_type& x);
\par \tab template <class InputIterator> 
\par \tab void insert(InputIterator first, InputIterator last);
\par \tab void erase(iterator position);
\par \tab size_type erase(const key_type& x);
\par \tab void erase(iterator first, iterator last);
\par 
\par // map operations:
\par 
\par \tab iterator find(const key_type& x);
\par \tab const_iterator find(const key_type& x) const;
\par \tab size_type count(const key_type& x) const;
\par \tab iterator lower_bound(const key_type& x);
\par \tab const_iterator lower_bound(const key_type& x) const;
\par \tab iterator upper_bound(const key_type& x);
\par \tab const_iterator upper_bound(const key_type& x) const;
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab pair<iterator, iterator> equal_range(const key_type& x);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab pair<const_iterator, const_iterator> equal_range(const key_type& x) const;
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \};
\par 
\par template <class Key, class T, class Compare, class Allocator>
\par bool operator==(const map<Key, T, Compare, Allocator>& x,
\par \tab \tab const map<Key, T, Compare, Allocator>& y);
\par 
\par template <class Key, class T, class Compare, class Allocator>
\par bool operator<(const map<Key, T, Compare, Allocator>& x,
\par \tab \tab const map<Key, T, Compare, Allocator>& y);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 iterator is a bidirectional iterator referring to value_type. The exact type is implementation dependent and determined by Allocator.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
const_iterator is a constant bidirectional iterator referring to const value_type. The exact type is implementation dependent and determined by Allocator. It is guaranteed that there is a constructor for const_iterator out of iterator.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 \tab \tab size_type is an unsigned integral type. The exact type is implementation dependent and determined by Allocator.
\par \tab difference_type is a signed integral type. The exact type is implementation dependent and determined by Allocator.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
In addition to the standard set of member functions of associative containers, map provides Allocator<T>::reference operator[](const key_type&). For a map m and key k, m[k] is semantically equivalent to (*((m.insert(make_pair(k, T()))).first)).second.

\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285551}8.2.4 Multimap}{\f9\fs20\cf1 {\*\bkmkend _Toc330285551}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 multimap is a kind of associative container that supports equal keys (possibly contains multiple copies of the same key value) and 
provides for fast retrieval of values of another type T based on the keys.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class Key, class T, class Compare = less<Key>,
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab template <class U> class Allocator = allocator>
\par class multimap \{
\par public:
\par 
\par // typedefs:
\par 
\par \tab typedef Key key_type;
\par \tab typedef pair<const Key, T> value_type;
\par \tab typedef Compare key_compare;
\par \tab class value_compare 
\par \tab \tab : public binary_function<\tab value_type, value_type, bool> \{
\par \tab friend class multimap;
\par \tab protected:
\par \tab \tab Compare comp;
\par \tab \tab value_compare(Compare c) : comp(c) \{\}
\par \tab public:
\par \tab \tab bool operator()(const value_type& x, const value_type& y) \{
\par \tab \tab \tab return comp(x.first, y.first);
\par \tab \tab \}
\par \tab \};
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab typedef iterator; 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab typedef const_iterator; 
\par \tab typedef Allocator<value_type>::pointer pointer;
\par \tab typedef Allocator<value_type>::reference reference;
\par \tab typedef Allocator<value_type>::const_reference const_reference;
\par \tab typedef size_type;
\par \tab typedef difference_type;
\par \tab typedef reverse_iterator;
\par \tab typedef const_reverse_iterator;
\par 
\par // allocation/deallocation:
\par 
\par \tab multimap(const Compare& comp = Compare());
\par \tab template <class InputIterator> 
\par \tab multimap(InputIterator first, InputIterator last,
\par \tab \tab const Compare& comp = Compare()); 
\par \tab multimap(const multimap<Key, T, Compare, Allocator>& x);
\par \tab ~multimap(); 
\par \tab multimap<Key, T, Compare, Allocator>&
\par \tab \tab operator=(const multimap<Key, T, Compare, Allocator>& x);
\par \tab void swap(multimap<Key, T, Compare, Allocator>& x);
\par 
\par // accessors:
\par 
\par \tab key_compare key_comp() const;
\par \tab value_compare value_comp() const;
\par \tab iterator begin();
\par \tab const_iterator begin() const;
\par \tab iterator end();
\par \tab const_iterator end() const;
\par \tab reverse_iterator rbegin();
\par \tab const_reverse_iterator rbegin();
\par \tab reverse_iterator rend();
\par \tab const_reverse_iterator rend();
\par \tab bool empty() const; 
\par \tab size_type size() const;
\par \tab size_type max_size() const;
\par 
\par // insert/erase:
\par 
\par \tab iterator insert(const value_type& x);
\par \tab iterator insert(iterator position, const value_type& x);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab template <class InputIterator> 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab void insert(InputIterator first, InputIterator last);
\par \tab void erase(iterator position);
\par \tab size_type erase(const key_type& x);
\par \tab void erase(iterator first, iterator last);
\par 
\par // multimap operations:
\par 
\par \tab iterator find(const key_type& x);
\par \tab const_iterator find(const key_type& x) const;
\par \tab size_type count(const key_type& x) const;
\par \tab iterator lower_bound(const key_type& x);
\par \tab const_iterator lower_bound(const key_type& x) const;
\par \tab iterator upper_bound(const key_type& x);
\par \tab const_iterator upper_bound(const key_type& x) const;
\par \tab pair<iterator, iterator> equal_range(const key_type& x);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab pair<const_iterator, const_iterator> equal_range(const key_type& x) const;
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \};
\par 
\par template <class Key, class T, class Compare, class Allocator>
\par bool operator==(const multimap<Key, T, Compare, Allocator>& x,
\par \tab \tab const multimap<Key, T, Compare, Allocator>& y);
\par 
\par template <class Key, class T, class Compare, class Allocator>
\par bool operator<(const multimap<Key, T, Compare, Allocator>& x,
\par \tab \tab const multimap<Key, T, Compare, Allocator>& y);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 iterator is a bidirectional iterator referring to value_type. The exact type is implementation dependent and determined by Allocator.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 const_iterator is the a constant bidirectional iterator referring to const
 value_type. The exact type is implementation dependent and determined by Allocator. It is guaranteed that there is a constructor for const_iterator out of iterator.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 \tab \tab size_type is an unsigned integral type. The exact type is implementation dependent and determined by Allocator.
\par \tab difference_type is a signed integral type. The exact type is implementation dependent and determined by Allocator.
\par }\pard\plain \s34\ri-548\sb320\sl280\slmult0\nowidctlpar \f8 {\b\f9\cf1 {\*\bkmkstart _Toc330285552}9  Stream iterators}{\f9\cf1 {\*\bkmkend _Toc330285552}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 To make it possible for algorithmic templates to work directly with input/output streams, appropriate iterator-like template classes are provided. For example,
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 partial_sum_copy(istream_iterator<double>(cin),\tab istream_iterator<double>(), 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab  ostream_iterator<double>(cout, \rdblquote \\n\rdblquote ));
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 reads a file containing floating point numbers from cin, and prints the partial sums onto cout.
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285553}9.1 Istream Iterator}{\f9\fs22\cf1 {\*\bkmkend _Toc330285553}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 
istream_iterator<T> reads (using operator>>) successive elements from the input stream for which it was constructed. After it is constructed, and every time ++ is used, the iterator reads and stores a value of T
. If the end of stream is reached (operator void*() on the stream returns false), the iterator becomes equal to the end-of-stream iterator value. The constructor with no arguments istream_iterator() always constructs an end of stream input iterator object
, which is the only legitimate iterator to be used for the end condition. The result of operator* on an end of stream is not defined. For any other iterator value a const T& is returned. It is impossible to store things into istream iterators. The main pe
culiarity of the istream iterators is the fact that ++ operators are not equality preserving, that is, i == j does not guarantee at all that ++i == ++j. Every time ++ is used a new value is read. 
\par }{\f18\fs20\cf1 
The practical consequence of this fact is that istream iterators can be used only for one-pass algorithms, which actually makes perfect sense, since for multi-pass algorithms it is always more appropriate to use in-memory data structures. Two end-of-strea
m iterators are always equal. An end-of-stream iterator is not equal to a non-end-of-stream iterator. Two non-end-of-stream iterators are equal when they are constructed from the same stream.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class T, class Distance = ptrdiff_t>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 class istream_iterator : public input_iterator<T, Distance> \{
\par friend bool operator==(const istream_iterator<T, Distance>& x,
\par                        const istream_iterator<T, Distance>& y);
\par public:
\par \tab istream_iterator();
\par \tab istream_iterator(istream& s);
\par \tab istream_iterator(const istream_iterator<T, Distance>& x);
\par \tab ~istream_iterator();
\par \tab const T& operator*() const;
\par \tab istream_iterator<T, Distance>& operator++();\tab 
\par \tab istream_iterator<T, Distance> operator++(int);\tab 
\par \};
\par template <class T, class Distance>
\par bool operator==(const istream_iterator<T, Distance>& x,
\par \tab \tab const istream_iterator<T, Distance>& y);
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285554}9.2 Ostream iterator}{\f9\fs22\cf1 {\*\bkmkend _Toc330285554}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
ostream_iterator<T> writes (using operator<<) successive elements onto the output stream from which it was constructed. If it was constructed with char* as a constructor argument, this string, called a delimiter string, is written to
 the stream after every T is written. It is not possible to get a value out of the output iterator. Its only use is as an output iterator in situations like 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 while (first != last) *result++ = *first++;
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 ostream_iterator is defined as:
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 class ostream_iterator : public output_iterator \{
\par public:
\par \tab ostream_iterator(ostream& s);\tab 
\par \tab ostream_iterator(ostream& s, const char* delimiter);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab ostream_iterator(const ostream_iterator<T>& x);\tab \tab \tab \tab \tab \tab \tab 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab ~ostream_iterator();
\par \tab ostream_iterator<T>& operator=(const T& value);\tab 
\par \tab ostream_iterator<T>& operator*();
\par \tab ostream_iterator<T>& operator++();
\par \tab ostream_iterator<T>& operator++(int);
\par \};
\par }\pard\plain \s34\ri-548\sb320\sl280\slmult0\nowidctlpar \f8 {\b\f9\cf1 {\*\bkmkstart _Toc330285555}10  Algorithms}{\f9\cf1 {\*\bkmkend _Toc330285555}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
All of the algorithms are separated from the particular implementations of data structures and are parameterized by iterator types. Because of this, they can work with user defined data structures, as long as these data structures have iterator types sati
sfying the assumptions on the algorithms. 
\par Both in-place and copying versions are provided for certain algorithms.
 The decision whether to include a copying version was usually based on complexity considerations. When the cost of doing the operation dominates the cost of copy, the copying version is not included. For example, sort_copy is not included since the cost 
of sorting is much more significant, and users might as well do copy followed by sort. When such a version is provided for }{\i\f3\fs18\cf1 
algorithm it is called algorithm_copy. Algorithms that take predicates end with the suffix _if (which follows the suffix _copy). }{\f3\fs18\cf1 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 The 
Predicate class is used whenever an algorithm expects a function object that when applied to the result of dereferencing the corresponding iterator returns a value convertible to bool. In other words, if an algorithm takes Predicate pred as its argument a
nd first as its iterator argument, it should work correctly in the construct if (pred(*first))\{...\}. The function object pred is assumed not to apply any non-constant function through the dereferenced iterator. 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 The BinaryPredicate class is used whenever an
 algorithm expects a function object that when applied to the result of dereferencing two corresponding iterators or to dereferencing an iterator and type T when T is part of the signature returns a value convertible to bool. In other words, if an algorit
hm takes BinaryPredicate binary_pred as its argument and first1 and first2 as its iterator arguments, it should work correctly in the construct if (binary_pred(*first, *first2))\{...\}
. BinaryPredicate always takes the first iterator type as its first argument, that is, in those cases when T value is part of the signature, it should work correctly in the context of if (binary_pred(*first, value))\{...\}
. It is expected that binary_pred will not apply any non-constant function through the dereferenced iterators.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
In the description of the algorithms operators + and - are used for some of the iterator categories for which they do not have to be defined. In these cases the semantics of a+n is the same as that of \{ X tmp = a; advance(tmp, n); return tmp; \}
 and that of a-b is the same as that of \{ Distance n; distance(a, b, n); return n; \}.
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285556}10.1 Non-mutating sequence operations}{\f9\fs22\cf1 {\*\bkmkend _Toc330285556}
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285557}10.1.1 For each}{\f9\fs20\cf1 {\*\bkmkend _Toc330285557}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class InputIterator, class Function>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 Function for_each(InputIterator first, InputIterator last, Function f);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
for_each applies f to the result of dereferencing every iterator in the range [first, last) and returns f. f is assumed not to apply any non-constant function through the dereferenced iterator. f is applied exactly last - first times. If f returns a resul
t, the result is ignored. 
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285558}10.1.2 Find}{\f9\fs20\cf1 {\*\bkmkend _Toc330285558}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class InputIterator, class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 InputIterator find(InputIterator first, InputIterator last, const T& value);
\par 
\par template <class InputIterator, class Predicate>
\par InputIterator find_if(InputIterator first, InputIterator last, Predicate pred);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
find returns the first iterator i in the range [first, last) for which the following corresponding conditions hold: *i == value, pred(*i) == true. If no such iterator is found, last is returned. Exactly find(first, last, value) - first
 applications of the corresponding predicate are done.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285559}10.1.3 Adjacent find}{\f9\fs20\cf1 {\*\bkmkend _Toc330285559}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class InputIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 InputIterator adjacent_find(InputIterator first, InputIterator last); 
\par 
\par template <class InputIterator, class BinaryPredicate>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 InputIterator adjacent_find(InputIterator first, InputIterator last, BinaryPredicate binary_pred);

\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 
adjacent_find returns the first iterator i such that both i and i + 1 are in the range [first, last) for which the following corresponding conditions hold: *i == *(i + 1), binary_
pred(*i, *(i + 1)) == true. If no such iterator i is found, last is returned. At most max((last - first) - 1, 0) applications of the corresponding predicate are done.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285560}10.1.4 Count}{\f9\fs20\cf1 {\*\bkmkend _Toc330285560}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class InputIterator, class T, class Size>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 void count(InputIterator first, InputIterator last, const T& value, Size& n);
\par 
\par template <class InputIterator, class Predicate, class Size>
\par void count_if(InputIterator first, InputIterator last, Predicate pred, Size& n);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 count adds to n the number of iterators i in the range [fir
st, last) for which the following corresponding conditions hold: *i == value, pred(*i) == true. Exactly last - first applications of the corresponding predicate are done.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 count must store the result into a reference argument instead of returning the result because the size type cannot be deduced from built-in iterator types such as int*.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285561}10.1.5 Mismatch}{\f9\fs20\cf1 {\*\bkmkend _Toc330285561}
\par 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class InputIterator1, class InputIterator2>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 
pair<InputIterator1, InputIterator2> mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 template <class InputIterator1, class InputIterator2, class BinaryPredicate>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 
pair<InputIterator1, InputIterator2> mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab BinaryPredicate binary_pred);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 
mismatch returns a pair of iterators i and j such that j == first2 + (i - first1) and i is the first iterator in the range [first1, last1) for which the following corresponding conditions hold: !(*i == *(first2 + (i - first1))), binary_pred(*i, *(first2 +
 (i - first1))) == false. If such an iterator i is not found, a pair of last1 and first2 + (last1 - first1) is returned. At most last1 - first1 applications of the corresponding predicate are done.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285562}10.1.6 Equal}{\f9\fs20\cf1 {\*\bkmkend _Toc330285562}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class InputIterator1, class InputIterator2>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 bool equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);
\par 
\par template <class InputIterator1, class InputIterator2, class BinaryPredicate>
\par bool equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,
\par \tab \tab BinaryPredicate binary_pred);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
equal returns true if for every iterator i in the range [first1, last1) the following corresponding conditions hold: *i == *(first2 + (i - first1)), binary_pred(*i, *(first2 + (i - first1))) == true. Otherwise, it returns false. At most last1 - first1 app
lications of the corresponding predicate are done.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285563}10.1.7 Search}{\f9\fs20\cf1 {\*\bkmkend _Toc330285563}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class ForwardIterator1, class ForwardIterator2>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1, 
\par \tab \tab ForwardIterator2 first2,\tab  \tab ForwardIterator2 last2);
\par 
\par template <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
\par ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1, 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 \tab \tab ForwardIterator2 first2,\tab  \tab ForwardIterator2 last2, BinaryPredicate binary_pred);

\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 search finds a subsequence of equal values in a sequence. }{\f3\fs18\cf1 
search returns the first iterator i in the range [first1, last1 - (last2 - first2)) such that for any non-negative integer n less than last2 - first2 the following corresponding conditions hold: *(i + n) == *(first2
 + n), binary_pred(*(i + n), *(first2 + n)) == true. If no such iterator is found, last1 is returned. At most (last1 - first1) * (last2 - first2) applications of the corresponding predicate are done. The quadratic behavior, however, is highly unlikely.

\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285564}10.2 Mutating sequence operations}{\f9\fs22\cf1 {\*\bkmkend _Toc330285564}
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285565}10.2.1 Copy}{\f9\fs20\cf1 {\*\bkmkend _Toc330285565}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class InputIterator, class OutputIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 OutputIterator copy(InputIterator first, InputIterator last, 
\par \tab \tab OutputIterator result);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 copy copies elements. For each non-negative integer n < (last - first),
 *(result + n) = *(first + n) is performed. copy returns result + (last - first). Exactly last - first assignments are done. The result of copy is undefined if result is in the range [first, last).
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class BidirectionalIterator1, class BidirectionalIterator2>
\par BidirectionalIterator2 copy_backward(BidirectionalIterator1 first,
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab BidirectionalIterator1 last, BidirectionalIterator2 result);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 copy_backward copies elements in the range [first, last) into the range [result - (last - first), result) startin
g from last - 1 and proceeding to first. It should be used instead of copy when last is in the range [result - (last - first), result). For each positive integer n <= (last - first), *(result - n) = *(last - n) is performed. copy_backward returns result -
 (last - first). Exactly last - first assignments are done. The result of copy_backward is undefined if result is in the range [first, last).
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285566}10.2.2 Swap}{\f9\fs20\cf1 {\*\bkmkend _Toc330285566}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 void swap(T& a, T& b);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 swap exchanges values stored in two locations.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class ForwardIterator1, class ForwardIterator2>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 void iter_swap(ForwardIterator1 a, ForwardIterator2 b);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 iter_swap exchanges values pointed by the two iterators a and b.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class ForwardIterator1, class ForwardIterator2>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 
ForwardIterator2 swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
For each non-negative integer n < (last1 - first1) the swap is performed: swap(*(first1 + n), *(first2 + n)). swap_ranges returns first2 + (last1 - first1). Exactly last1 - first1 swaps are done. The result of }{\f3\fs18\cf1 
swap_ranges is undefined if the two ranges [first1, last1) and [first2, first2 + (last1 - first1)) overlap.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285567}10.2.3 Transform}{\f9\fs20\cf1 {\*\bkmkend _Toc330285567}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class InputIterator, class OutputIterator, class UnaryOperation>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 OutputIterator transform(InputIterator first, InputIterator last,
\par \tab \tab OutputIterator result, UnaryOperation op);
\par 
\par template <class InputIterator1, class InputIterator2, class OutputIterator,
\par \tab \tab class BinaryOperation>
\par OutputIterator transform(InputIterator1 first1, InputIterator1 last1,
\par \tab \tab InputIterator2 first2,\tab  OutputIterator result, 
\par \tab \tab BinaryOperation binary_op);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 
transform assigns through every iterator i in the range [result, result + (last1 - first1)) a new corresponding value equal to op(*(first1 + (i - result)) or binary_op(*(first1 + (i - result), *(first2 + (i - result))). transform returns result + (last1 -
 first1). Exactly last1 - first1 applications of op or binary_op are performed. op and binary_op are expected not to have any side effects. result may be equal to first in case of unary transform, or to first1 or first2 in case of binary transform.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285568}10.2.4 Replace}{\f9\fs20\cf1 {\*\bkmkend _Toc330285568}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class ForwardIterator, class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 void replace(ForwardIterator first, ForwardIterator last, const T& old_value,
\par \tab \tab const T& new_value);
\par 
\par template <class ForwardIterator, class Predicate, class T>
\par void replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, 
\par \tab \tab const T& new_value);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 replace substitutes elements referred by the iterator i in the range [first, last) with new_value, when the following co
rresponding conditions hold: *i == old_value, pred(*i) == true. Exactly last - first applications of the corresponding predicate are done.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class InputIterator, class OutputIterator, class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 OutputIterator replace_copy(InputIterator first, InputIterator last, OutputIterator result, \tab 
\tab const T& old_value, const T& new_value);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 template <class Iterator, class OutputIterator, class Predicate, class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 OutputIterator replace_copy_if(Iterator first, Iterator last,
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab OutputIterator result, \tab \tab Predicate pred, const T& new_value);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 
replace_copy assigns to every iterator i in the range [result, result + (last - first)) either new_value or *(first + (i - result)) depending on whether the following corresponding conditions hold: *(first + (i - result)) == old_value, pred(*(first + (i -
 result))) == true. replace_copy returns result + (last - first). Exactly last - first applications of the corresponding predicate are done.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285569}10.2.5 Fill}{\f9\fs20\cf1 {\*\bkmkend _Toc330285569}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class ForwardIterator, class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 void fill(ForwardIterator first, ForwardIterator last, const T& value);
\par 
\par template <class OutputIterator, class Size, class T>
\par OutputIterator fill_n(OutputIterator first, Size n, const T& value);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 fill assigns value through all the iterators in the range [first, last) or [first, first + n). fill_n returns first + n. Exactly last - first (or n) assignments are done. 

\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285570}10.2.6 Generate}{\f9\fs20\cf1 {\*\bkmkend _Toc330285570}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class ForwardIterator, class Generator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 void generate(ForwardIterator first, ForwardIterator last, Generator gen);
\par 
\par template <class OutputIterator, class Size, class Generator>
\par OutputIterator generate_n(OutputIterator first, Size n, Generator gen);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
generate invokes the function object gen and assigns the return value of gen through all the iterators in the range [first, last) or [first, first + n). gen takes no arguments. generate_n returns first + n. Exactly last - first (or n) invocations of gen a
nd assignments are done. 
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285571}10.2.7 Remove}{\f9\fs20\cf1 {\*\bkmkend _Toc330285571}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class ForwardIterator, class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 ForwardIterator remove(ForwardIterator first, ForwardIterator last,
\par \tab \tab const T& value);
\par 
\par template <class ForwardIterator, class Predicate>
\par ForwardIterator remove_if(ForwardIterator first, ForwardIterator last,
\par \tab \tab Predicate pred);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 
remove eliminates all the elements referred to by iterator i in the range [first, last) for which the following corresponding conditions hold: *i == value, pred(*i) == true. remove returns the end of the resulting range. remove is stable, that is, the rel
ative order of the elements that are not removed is the same as their relative order in the original range. Exactly last - first applications of the corresponding predicate are done. 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class InputIterator, class OutputIterator, class T>
\par OutputIterator remove_copy(InputIterator first, InputIterator last, 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab OutputIterator result, \tab \tab const T& value);
\par 
\par template <class InputIterator, class OutputIterator, class Predicate>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 OutputIterator remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, 
\tab \tab Predicate pred);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 remove_copy copies all the elements referred to by the iterator i in the ra
nge [first, last) for which the following corresponding conditions do not hold: *i == value, pred(*i) == true. remove_copy returns the end of the resulting range. remove_copy is stable, that is, the relative order of the elements in the resulting range is
 the same as their relative order in the original range. Exactly last - first applications of the corresponding predicate are done.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285572}10.2.8 Unique}{\f9\fs20\cf1 {\*\bkmkend _Toc330285572}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class ForwardIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 ForwardIterator unique(ForwardIterator first, ForwardIterator last);
\par 
\par template <class ForwardIterator, class BinaryPredicate>
\par ForwardIterator unique(ForwardIterator first, ForwardIterator last, 
\par \tab \tab BinaryPredicate binary_pred);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 
unique eliminates all but the first element from every consecutive group of equal elements referred to by the iterator i in the range [first, last) for which the following corresponding conditions hold: *i == *(i - 1)or binary_pred(*i, *(i - 1)) == true. 
unique returns the end of the resulting range. Exactly (last - first) - 1 applications of the corresponding predicate are done.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class InputIterator, class OutputIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 OutputIterator unique_copy(InputIterator first, InputIterator last, OutputIterator result);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 template <class InputIterator, class OutputIterator, class BinaryPredicate>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 OutputIterator unique_copy(InputIterator first, InputIterator last, OutputIterator result, \tab 
\tab BinaryPredicate binary_pred);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 unique_copy copies only the first element from every consecutive group of equal elements referred to by the iterator i in the range [first, last)
 for which the following corresponding conditions hold: *i == *(i - 1)or binary_pred(*i, *(i - 1)) == true. unique_copy returns the end of the resulting range. Exactly last - first applications of the corresponding predicate are done.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285573}10.2.9 Reverse}{\f9\fs20\cf1 {\*\bkmkend _Toc330285573}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class BidirectionalIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 void reverse(BidirectionalIterator first, BidirectionalIterator last);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 For each non-negative integer i <= (last - first)/2, reverse applies swap to all pairs of iterators first + i, (last - i) - 1. Exactly (last - first)/2 swaps are performed.

\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class BidirectionalIterator, class OutputIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 OutputIterator reverse_copy(BidirectionalIterator first,
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab BidirectionalIterator last, \tab \tab OutputIterator result);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
reverse_copy copies the range [first, last) to the range [result, result + (last - first)) such that for any non-negative integer i < (last - first) the following assignment takes place: *(result + (last - first) - i) = *(first + i). reverse_copy returns 
result + (last - first).Exactly last - first assignments are done. The result of reverse_copy is undefined if [first, last) and [result, result + (last - first)) overlap.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285574}10.2.10 Rotate}{\f9\fs20\cf1 {\*\bkmkend _Toc330285574}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class ForwardIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 void rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
For each non-negative integer i < (last - first), rotate places the element from the position first + i into position first + (i + (last - middle)) % (last - first). [first, middle) and [middle, last) are valid ranges. At most last - first swaps are done.

\par 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class ForwardIterator, class OutputIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 OutputIterator rotate_copy(ForwardIterator first, ForwardIterator middle,
\par \tab \tab ForwardIterator last, OutputIterator result);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 
rotate_copy copies the range [first, last) to the range [result, result + (last - first)) such that for each non-negative integer i < (last - first) the following assignment takes place: *(result + (i + (last - middle)) % (last - first)) = *(first + i). r
otate_copy returns result + (last - first). Exactly last - first assignments are done. The result of rotate_copy is undefined if [first, last) and [result, result + (last - first)) overlap.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285575}10.2.11 Random shuffle}{\f9\fs20\cf1 {\*\bkmkend _Toc330285575}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class RandomAccessIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 void random_shuffle(RandomAccessIterator first, RandomAccessIterator last);
\par 
\par template <class RandomAccessIterator, class RandomNumberGenerator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 
void random_shuffle(RandomAccessIterator first, RandomAccessIterator last, RandomNumberGenerator& rand);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 random_shuffle shuffles the elements in the range [first, last) with uniform distribution. Exactly (last
 - first) - 1 swaps are done. random_shuffle can take a particular random number generating function object rand such that rand takes a positive argument n of distance type of the RandomAccessIterator and returns a randomly chosen value between 0 and n-1.
 
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285576}10.2.12 Partitions}{\f9\fs20\cf1 {\*\bkmkend _Toc330285576}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class BidirectionalIterator, class Predicate>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 BidirectionalIterator partition(BidirectionalIterator first,
\par \tab \tab BidirectionalIterator last, \tab \tab Predicate pred);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 partition places all the elements in the range [first, last) that sat
isfy pred before all the elements that do not satisfy it. It returns an iterator i such that for any iterator j in the range [first, i), pred(*j) == true, and for any iterator k in the range [i, last), pred(*j) == false. It does at most (last - first)/ 2 
swaps. Exactly last - first applications of the predicate is done.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class BidirectionalIterator, class Predicate>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 BidirectionalIterator stable_partition(BidirectionalIterator first, 
\par \tab \tab Bidirectional\tab Iterator last, \tab \tab Predicate pred);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 stable_partiti
on places all the elements in the range [first, last) that satisfy pred before all the elements that do not satisfy it. It returns an iterator i such that for any iterator j in the range [first, i), pred(*j) == true, and for any iterator k in the range [i
, last), pred(*j) == false. The relative order of the elements in both groups is preserved. It does at most (last - first) * log(last - first) swaps, but only linear number of swaps if there is enough extra memory. Exactly last - first applications of the
 predicate are done.
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285577}10.3 Sorting and related operations}{\f9\fs22\cf1 {\*\bkmkend _Toc330285577}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 All the operations in this section have two versions: one that takes a function object of type Compare and one that uses an operator<.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
Compare is a function object which returns a value convertible to bool. Compare comp is used throughout for algorithms assuming an ordering relation. comp satisfies the standard axioms for total ordering and it does not apply any non-constant function thr
ough the dereferenced iterator. For all algorithms that take Compare, there is a version that uses operator< instead. That is, comp(*i, *j) == true defaults to *i < *j == true.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
A sequence is sorted with respect to a comparator comp if for any iterator i pointing to an element in a sequence and any non-negative integer n such that i + n is a valid iterator pointing to an element of the same sequence, comp(*(i + n), *i) == false.

\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
In the descriptions of the functions that deal with ordering relationships we frequently use a notion of equality to describe concepts such as stability. The equality to which we refer is not necessar
ily an operator==, but an equality relation induced by the total ordering. That is, two element a and b are considered equal if and only if !(a < b) && !(b < a).
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285578}10.3.1 Sort}{\f9\fs20\cf1 {\*\bkmkend _Toc330285578}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class RandomAccessIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 void sort(RandomAccessIterator first, RandomAccessIterator last);
\par 
\par template <class RandomAccessIterator, class Compare>
\par void sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 sort sorts the elements in the range [first, last). It does approximately NlogN (where N equals to 
last - first) comparisons on the average. If the worst case behavior is important stable_sort or partial_sort should be used.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class RandomAccessIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 void stable_sort(RandomAccessIterator first, RandomAccessIterator last);
\par 
\par template <class RandomAccessIterator, class Compare>
\par void stable_sort(RandomAccessIterator first, RandomAccessIterator last,
\par \tab \tab Compare comp);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 stable_sort sorts the elements in the range [first, last). It is stable, that is, the relative order of the equal elements is prese
rved. It does at most N(logN)2 (where N equals to last - first) comparisons; if enough extra memory is available, it is NlogN.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class RandomAccessIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 void partial_sort(RandomAccessIterator first, RandomAccessIterator middle,
\par \tab \tab RandomAccessIterator last);
\par 
\par template <class RandomAccessIterator, class Compare>
\par void partial_sort(RandomAccessIterator first, RandomAccessIterator middle,
\par \tab \tab RandomAccessIterator last, \tab \tab Compare comp);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 partial_sort places the first middle - first sorted elements from 
the range [first, last) into the range [first, middle). The rest of the elements in the range [middle, last) are placed in an undefined order. It takes approximately (last - first) * log(middle - first) comparisons. 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class InputIterator, class RandomAccessIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 RandomAccessIterator partial_sort_copy(InputIterator first, InputIterator last,
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 \tab \tab RandomAccessIterator result_first, RandomAccessIterator result_last);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 template <class InputIterator, class RandomAccessIterator, class Compare>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 RandomAc
cessIterator partial_sort_copy(InputIterator first, InputIterator last, RandomAccessIterator result_first, RandomAccessIterator result_last, \tab \tab Compare comp);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 
partial_sort_copy places the first min(last - first, result_last - result_first) sorted elements into the range [result_first, result_first + min(last - first, result_last - result_first)). It returns either result_last or result_first + (last - first) wh
ichever is smaller. It takes approximately (last - first) * log(min(last - first, result_last - result_first)) comparisons.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285579}10.3.2 Nth element}{\f9\fs20\cf1 {\*\bkmkend _Toc330285579}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class RandomAccessIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 void nth_element(RandomAccessIterator first, \tab \tab RandomAccessIterator nth,
\par \tab \tab RandomAccessIterator last);
\par 
\par template <class RandomAccessIterator, class Compare>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 
void nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 After }{\f3\fs18\cf1 nth_element the element in the position pointed to by nth is the element that would be in that position if the whole range were sorted. Also for any iter
ator i in the range [first, nth) and any iterator j in the range [nth, last) it holds that !(*i > *j) or comp(*i, *j) == false. It is linear on the average. 
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285580}10.3.3 Binary search}{\f9\fs20\cf1 {\*\bkmkend _Toc330285580}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
All of the algorithms in this section are versions of binary search. They work on non-random access iterators minimizing the number of comparisons, which will be logarithmic for all types of iterators. They are especially appropriate for random access ite
rators, since these algorithms do a logarithmic number of steps through the data structure. For non-random access iterators they execute a linear number of steps.
\par 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class ForwardIterator, class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, 
\par \tab \tab const T& value);
\par 
\par template <class ForwardIterator, class T, class Compare>
\par ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, 
\par \tab \tab const T& value, Compare comp);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 lower_bound finds the first position into which value can be inserted without violating the ordering. lower_bound returns the 
furthermost iterator i in the range [first, last) such that for any iterator j in the range [first, i) the following corresponding conditions hold: *j < value or comp(*j, value) == true. At most log(last - first) + 1 comparisons are done.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class ForwardIterator, class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last, 
\par \tab \tab const T& value);
\par 
\par template <class ForwardIterator, class T, class Compare>
\par ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last, 
\par \tab \tab const T& value, \tab \tab Compare comp);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
upper_bound finds the furthermost position into which value can be inserted without violating the ordering. upper_bound returns the furthermost iterator i in the range [first, last) such that for any iterator j in the range [first, i) the following corres
ponding conditions hold: !(value < *j) or comp(value, *j) == false. At most log(last - first) + 1 comparisons are done.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class ForwardIterator, class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 pair<ForwardIterator, ForwardIterator> equal_range(ForwardIterator first, 
\par \tab \tab ForwardIterator last, \tab \tab const T& value);
\par 
\par template <class ForwardIterator, class T, class Compare>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 
pair<ForwardIterator, ForwardIterator> equal_range(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
equal_range finds the largest subrange [i, j) such that the value can be inserted at any iterator k in it. k satisfies the corresponding conditions: !(*k < value) && !(value < *k) or comp(*k, value) == false && comp(value, *k) == false. At most 2 * log(la
st - first) + 1 comparisons are done.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class ForwardIterator, class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 bool binary_search(ForwardIterator first, ForwardIterator last, const T& value);
\par 
\par template <class ForwardIterator, class T, class Compare>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 bool binary_search(ForwardIterator first, ForwardIterator last, \tab \tab const T& value,
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab Compare comp);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
binary_search returns true if there is an iterator i in the range [first last) that satisfies the corresponding conditions: !(*i < value) && !(value < *i) or comp(*i, value) == false && comp(value, *i) == false.
 At most log(last - first) + 2 comparisons are done.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285581}10.3.4 Merge}{\f9\fs20\cf1 {\*\bkmkend _Toc330285581}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class InputIterator1, class InputIterator2, class OutputIterator>
\par OutputIterator merge(InputIterator1 first1, InputIterator1 last1, 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab InputIterator2 first2, \tab \tab InputIterator2 last2, \tab \tab \tab 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab OutputIterator result);
\par 
\par template <class InputIterator1, class InputIterator2, class OutputIterator, 
\par \tab class Compare>
\par OutputIterator merge(InputIterator1 first1, InputIterator1 last1, 
\par \tab \tab InputIterator2 first2, \tab \tab InputIterator2 last2,
\par \tab \tab OutputIterator result, Compare comp);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 
merge merges two sorted ranges [first1, last1) and [first2, last2) into the range [result, result + (last1 - first1) + (last2 - first2)). The merge is stable, that is, for equal elements in the two ranges, the elements from the first range always precede 
the elements from the second. merge returns result + (last1 - first1) + (last2 - first2). At most (last1 - first1) + (last2 - first2) - 1 comparisons are performed. The result of merge is undefined if the resulting range overlaps 
with either of the original ranges.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class BidirectionalIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 void inplace_merge(BidirectionalIterator first, BidirectionalIterator middle,
\par \tab \tab BidirectionalIterator last);
\par 
\par template <class BidirectionalIterator, class Compare>
\par void inplace_merge(BidirectionalIterator first, BidirectionalIterator middle,
\par \tab \tab BidirectionalIterator last, Compare comp);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 inplace_merge merges two sorted consecutive ranges [first, middle) and [middle, last) putting the result of the merge into the range [first, last). T
he merge is stable, that is, for equal elements in the two ranges, the elements from the first range always precede the elements from the second. When enough additional memory is available, at most (last - first) - 1 comparisons are performed. If no addit
ional memory is available, an algorithm with O(NlogN) complexity may be used. 
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285582}10.3.5 Set operations on sorted structures}{\f9\fs20\cf1 {\*\bkmkend _Toc330285582}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 This section defines all the basic set operations on sorted structures. They even work with multisets containing multiple copies of equ
al elements. The semantics of the set operations is generalized to multisets in a standard way by defining union to contain the maximum number of occurrences of every element, intersection to contain the minimum, and so on. 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class InputIterator1, class InputIterator2>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 bool includes(InputIterator1 first1, InputIterator1 last1, 
\par \tab \tab InputIterator2 first2, \tab \tab InputIterator2 last2);
\par 
\par template <class InputIterator1, class InputIterator2, class Compare>
\par bool includes(InputIterator1 first1, InputIterator1 last1,
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab InputIterator2 first2, \tab \tab InputIterator2 last2, \tab \tab Compare comp);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 
includes returns true if every element in the range [first2, last2) is contained in the range [first1, last1). It returns false otherwise. At most ((last1 - first1) + (last2 - first2)) * 2 - 1 comparisons are performed.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class InputIterator1, class InputIterator2, class OutputIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 OutputIterator set_union(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, \tab 
\tab InputIterator2 last2, 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab OutputIterator result);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 template <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 OutputIterator set_union(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, \tab 
\tab InputIterator2 last2,
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab OutputIterator result, Compare comp);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 
set_union constructs a sorted union of the elements from the two ranges. It returns the end of the constructed range. set_union is stable, that is, if an element is present in both ranges, the one from the first range is copied. At most ((last1 - first1) 
+ (last2 - first2)) * 2 - 1 comparisons are performed. The result of set_union is undefined if the resulting range overlaps with either of the original ranges.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class InputIterator1, class InputIterator2, class OutputIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 OutputIterator set_intersection(InputIterator1 first1, InputIterator1 last1,
\par \tab \tab InputIterator2 first2, \tab \tab InputIterator2 last2, 
\par \tab \tab OutputIterator result);
\par 
\par template <class InputIterator1, class InputIterator2, class OutputIterator, 
\par \tab class Compare>
\par OutputIterator set_intersection(InputIterator1 first1, InputIterator1 last1,
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 \tab \tab InputIterator2 first2,\~\tab \tab InputIterator2 last2, \tab \tab \tab 
OutputIterator result, \tab \tab Compare comp);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 
set_intersection constructs a sorted intersection of the elements from the two ranges. It returns the end of the constructed range. set_intersection is guaranteed to be stable, that is, if an element is present in both ranges, the one from the first range
 is copied. At most ((last1 - first1) + (last2 - first2)) * 2 - 1 comparisons are performed. The result of set_intersection is undefined if the resulting range overlaps with either of the original ranges.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class InputIterator1, class InputIterator2, class OutputIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 OutputIterator set_difference(InputIterator1 first1, InputIterator1 last1,
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab InputIterator2 first2, \tab \tab InputIterator2 last2, \tab \tab \tab 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab OutputIterator result);
\par 
\par template <class InputIterator1, class InputIterator2, class OutputIterator, 
\par \tab class Compare>
\par OutputIterator set_difference(InputIterator1 first1, InputIterator1 last1,
\par \tab \tab InputIterator2 first2, \tab \tab InputIterator2 last2, 
\par \tab \tab OutputIterator result, \tab \tab Compare comp);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 
set_difference constructs a sorted difference of the elements from the two ranges. It returns the end of the constructed range. At most ((last1 - first1) + (last2 - first2)) * 2 - 1 comparisons are performed. The result of set_difference is undefined if t
he resulting range overlaps with either of the original ranges.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class InputIterator1, class InputIterator2, class OutputIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 OutputIterator set_symmetric_difference(InputIterator1 first1, InputIterator1 last1, \tab \tab 
InputIterator2 first2, \tab \tab \tab InputIterator2 last2, 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab OutputIterator result);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 
\par template <class InputIterator1, class InputIterator2, class OutputIterator, 
\par \tab class Compare>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 {\f3\fs18\cf1 OutputIterator set_symmetric_difference(InputIterator1 first1, InputIterator1 last1, \tab \tab 
InputIterator2 first2, \tab \tab \tab InputIterator2 last2, 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab OutputIterator result, \tab \tab Compare comp);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 set_symmetric_difference constructs a sorted symmetric difference of the elements from the two ranges. It returns the end of the co
nstructed range. At most ((last1 - first1) + (last2 - first2)) * 2 - 1 comparisons are performed. The result of set_symmetric_difference is undefined if the resulting range overlaps with either of the original ranges.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285583}10.3.6 Heap operations}{\f9\fs20\cf1 {\*\bkmkend _Toc330285583}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
A heap is a particular organization of elements in a range between two random access iterators [a, b). Its two key properties are: (1) *a is the largest element in the range and (2) *a may be removed by pop_heap, or a new element added by push_heap, in O(
logN) time. These properties make heaps useful as priority queues. make_heap converts a range into a heap and sort_heap turns a heap into a sorted sequence.
\par 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class RandomAccessIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 void push_heap(RandomAccessIterator first, RandomAccessIterator last);
\par 
\par template <class RandomAccessIterator, class Compare>
\par void push_heap(RandomAccessIterator first, RandomAccessIterator last,
\par \tab \tab Compare comp);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 push_heap assumes the range [first, last - 1) is a valid heap and properly places the value in the location last - 1 int
o the resulting heap [first, last). At most log(last - first) comparisons are performed.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class RandomAccessIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 void pop_heap(RandomAccessIterator first, RandomAccessIterator last);
\par 
\par template <class RandomAccessIterator, class Compare>
\par void pop_heap(RandomAccessIterator first, RandomAccessIterator last,
\par \tab \tab Compare comp);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 pop_heap assumes the range [first, last) is a valid heap, then swaps the value in the location first with the value in the location last - 1 and makes [first, last - 1) into 
a heap. At most 2 * log(last - first) comparisons are performed.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class RandomAccessIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 void make_heap(RandomAccessIterator first, RandomAccessIterator last);
\par 
\par template <class RandomAccessIterator, class Compare>
\par void make_heap(RandomAccessIterator first, RandomAccessIterator last,
\par \tab \tab Compare comp);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 make_heap constructs a heap out of the range [first, last). At most 3*(last - first) comparisons are performed.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class RandomAccessIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 void sort_heap(RandomAccessIterator first, RandomAccessIterator last);
\par 
\par template <class RandomAccessIterator, class Compare>
\par void sort_heap(RandomAccessIterator first, RandomAccessIterator last,
\par \tab \tab Compare comp);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 sort_heap sorts elements in the heap [first, last). At most NlogN comparisons are performed where N is equal to last - first. sort_heap is not stable.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285584}10.3.7 Minimum and maximum}{\f9\fs20\cf1 {\*\bkmkend _Toc330285584}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 const T& min(const T& a, const T& b);
\par 
\par template <class T, class Compare>
\par const T& min(const T& a, const T& b, Compare comp);
\par 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 template <class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 const T& max(const T& a, const T& b);
\par 
\par template <class T, class Compare>
\par const T& max(const T& a, const T& b, Compare comp);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 min returns the smaller and max the larger. min and max return the first argument when their arguments are equal.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class InputIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 InputIterator max_element(InputIterator first, InputIterator last);
\par 
\par template <class InputIterator, class Compare>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 InputIterator max_element(InputIterator first, InputIterator last, Compare comp);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 max_element returns the first iterator i in th
e range [first, last) such that for any iterator j in the range [first, last) the following corresponding conditions hold: !(*i < *j) or comp(*i, *j) == false. Exactly max((last - first) - 1, 0) applications of the corresponding comparisons are done.

\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class InputIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 InputIterator min_element(InputIterator first, InputIterator last);
\par 
\par template <class InputIterator, class Compare>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 InputIterator min_element(InputIterator first, InputIterator last, Compare comp);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 min_element returns the first it
erator i in the range [first, last) such that for any iterator j in the range [first, last) the following corresponding conditions hold: !(*j < *i) or comp(*j, *i) == false. Exactly max((last - first) - 1, 0)applications of the corresponding comparisons a
re done.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285585}10.3.8 Lexicographical comparison}{\f9\fs20\cf1 {\*\bkmkend _Toc330285585}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class InputIterator1, class InputIterator2>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 bool lexicographical_compare(InputIterator1 first1, InputIterator1 last1, 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab InputIterator2 first2, \tab \tab \tab InputIterator2 last2);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 
\par template <class InputIterator1, class InputIterator2, class Compare>
\par bool lexicographical_compare(InputIterator1 first1, InputIterator1 last1, 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab InputIterator2 first2,\tab \tab \tab  InputIterator2 last2, Compare comp);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 
lexicographical_compare returns true if the sequence of elements defined by the range [first1, last1) is lexicographically less than the sequence of elements defined by the range [first2, last2). It returns false otherwise. At most min((last1 - first1), (
last2 - first2)) applications of the corresponding comparison are done.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285586}10.3.9 Permutation generators}{\f9\fs20\cf1 {\*\bkmkend _Toc330285586}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class BidirectionalIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 bool next_permutation(BidirectionalIterator first, BidirectionalIterator last);
\par 
\par template <class BidirectionalIterator, class Compare>
\par bool next_permutation(BidirectionalIterator first, BidirectionalIterator last,
\par \tab \tab Compare comp);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 
next_permutation takes a sequence defined by the range [first, last) and transforms it into the next permutation. The next permutation is found by assuming that the set of all permutations is lexicographically sorted wi
th respect to operator< or comp. If such a permutation exists, it returns true. Otherwise, it transforms the sequence into the smallest permutation, that is, the ascendingly sorted one, and returns false. At most (last - first)/2 swaps are performed.

\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class BidirectionalIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 bool prev_permutation(BidirectionalIterator first, BidirectionalIterator last);
\par 
\par template <class BidirectionalIterator, class Compare>
\par bool prev_permutation(BidirectionalIterator first, BidirectionalIterator last,
\par \tab \tab Compare comp);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 
prev_permutation takes a sequence defined by the range [first, last) and transforms it into the previous permutation. The previous permutation is found by assuming that the set of all permutations is lexicographically sorted with respect to operator< or c
omp. If such a permutation exists, it returns true. Otherwise, it transforms the sequence into the largest permutation, that is, the descendingly sorted one, and returns false. At most (last - first)/2 swaps are performed.
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285587}10.4 Generalized numeric operations}{\f9\fs22\cf1 {\*\bkmkend _Toc330285587}
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285588}10.4.1 Accumulate}{\f9\fs20\cf1 {\*\bkmkend _Toc330285588}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class InputIterator, class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 T accumulate(InputIterator first, InputIterator last, T init);
\par 
\par template <class InputIterator, class T, class BinaryOperation>
\par T accumulate(InputIterator first, InputIterator last, T init, 
\par \tab \tab BinaryOperation binary_op);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
accumulate is similar to the APL reduction operator and Common Lisp reduce function, but it avoids the difficulty of defining the result of reduction on an empty sequence by always requiring an initial value. Accumulation is done \tab 
by initializing the accumulator acc with the initial value init and then modifying it with acc = acc + *i or acc = binary_op(acc, *i) for every iterator i in the range [first, last) in order. binary_op is assumed not to cause side effects.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285589}10.4.2 Inner product}{\f9\fs20\cf1 {\*\bkmkend _Toc330285589}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class InputIterator1, class InputIterator2, class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 T inner_product(InputIterator1 first1, InputIterator1 last1, 
\par \tab \tab InputIterator2 first2, \tab \tab T init);
\par 
\par template <class InputIterator1, class InputIterator2, class T, 
\par \tab \tab class BinaryOperation1, \tab \tab class BinaryOperation2>
\par T inner_product(InputIterator1 first1, InputIterator1 last1, \tab \tab 
\par \tab \tab InputIterator2 \tab \tab first2, \tab T init, 
\par \tab \tab BinaryOperation1 binary_op1, BinaryOperation2 binary_op2);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
inner_product computes its result by initializing the accumulator acc with the initial value init and then modifying it with acc = acc + (*i1) * (*i2) or acc = binary_op1(acc, binary_op2(*i1, *i2)) for every iterator i1 in the range [first, last) and iter
ator i2 in the range [first2, first2 + (last - first)) in order. binary_op1 and binary_op2 are assumed not to cause side effects.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285590}10.4.3 Partial sum}{\f9\fs20\cf1 {\*\bkmkend _Toc330285590}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class InputIterator, class OutputIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 OutputIterator partial_sum(InputIterator first, InputIterator last, 
\par \tab \tab OutputIterator result);
\par 
\par template <class InputIterator, class OutputIterator, class BinaryOperation>
\par OutputIterator partial_sum(InputIterator first, InputIterator last,
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab OutputIterator result, \tab \tab BinaryOperation binary_op);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 partial_sum assigns to every iterator i in the range [result, result + 
(last - first)) a value correspondingly equal to ((...(*first + *(first + 1)) + ... )+ *(first + (i - result))) or binary_op(binary_op(..., binary_op(*first, *(first + 1)),...), *(first + (i - result))). partial_sum returns result + (last - first). Exactl
y (last - first) - 1 applications of binary_op are performed. binary_op is expected not to have any side effects. result may be equal to first. 
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285591}10.4.4 Adjacent difference}{\f9\fs20\cf1 {\*\bkmkend _Toc330285591}
\par }\pard \s40\ri-548\sb160\sl260\slmult0\nowidctlpar {\f9\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class InputIterator, class OutputIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 OutputIterator adjacent_difference(InputIterator first, InputIterator last, 
\par \tab \tab OutputIterator result);
\par 
\par template <class InputIterator, class OutputIterator, class BinaryOperation>
\par OutputIterator adjacent_difference(InputIterator first, InputIterator last, 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab OutputIterator result, \tab \tab BinaryOperation binary_op);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
adjacent_difference assigns to every element referred to by iterator i in the range [result + 1, result + (last - first)) a value correspondingly equal to *(first + (i - result)) - *(first + (i - result) - 1)or binary_op(*(first + 
(i - result)), *(first + (i - result) - 1)). result gets the value of *first. adjacent_difference returns result + (last - first). Exactly (last - first) - 1 applications of binary_op are performed. binary_op is expected not to have any side effects. resu
lt may be equal to first.
\par }\pard\plain \s34\ri-548\sb320\sl280\slmult0\nowidctlpar \f8 {\b\f9\cf1 {\*\bkmkstart _Toc330285592}11  Adaptors}{\f9\cf1 {\*\bkmkend _Toc330285592}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 Adaptors are template classes that provide interface mappings. For example, insert_iterator provides a container with an output iterator interface.
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285593}11.1 Container adaptors}{\f9\fs22\cf1 {\*\bkmkend _Toc330285593}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 It is often useful to provide restricted inter
faces to containers. The library provides stack, queue and priority_queue through the adaptors that can work with different sequence types.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285594}11.1.1 Stack}{\f9\fs20\cf1 {\*\bkmkend _Toc330285594}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 Any sequence supporting operations back, push_back and pop_back can be used to instantiate stack. In particular, vector, list and deque can be used.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class Container>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 class stack \{
\par friend bool operator==(const stack<Container>& x, const stack<Container>& y);
\par friend bool operator<(const stack<Container>& x, const stack<Container>& y);
\par public:
\par \tab typedef Container::value_type value_type;
\par \tab typedef Container::size_type size_type;
\par protected:
\par \tab Container c;
\par public:
\par \tab bool empty() const \{ return c.empty(); \}
\par \tab size_type size() const \{ return c.size(); \}
\par \tab value_type& top() \{ return c.back(); \}
\par \tab const value_type& top() const \{ return c.back(); \}
\par \tab void push(const value_type& x) \{ c.push_back(x); \}
\par \tab void pop() \{ c.pop_back(); \}
\par \};
\par 
\par template <class Container>
\par bool operator==(const stack<Container>& x, const stack<Container>& y) \{
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab return x.c == y.c;
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \}
\par 
\par template <class Container>
\par bool operator<(const stack<Container>& x, const stack<Container>& y) \{
\par \tab return x.c < y.c;
\par \}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 For example, stack<vector<int> > is an integer stack made out of vector, and stack<deque<char> > is a character stack made out of deque.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285595}11.1.2 Queue}{\f9\fs20\cf1 {\*\bkmkend _Toc330285595}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 Any sequence supporting operations front, back, push_back and pop_front can be used to instantiate queue. In particular, list and deque can be used.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class Container>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 class queue \{
\par friend bool operator==(const queue<Container>& x, const queue<Container>& y);
\par friend bool operator<(const queue<Container>& x, const queue<Container>& y);
\par public:
\par \tab typedef Container::value_type value_type;
\par \tab typedef Container::size_type size_type;
\par protected:
\par \tab Container c;
\par public:
\par \tab bool empty() const \{ return c.empty(); \}
\par \tab size_type size() const \{ return c.size(); \}
\par \tab value_type& front() \{ return c.front(); \}
\par \tab const value_type& front() const \{ return c.front(); \}
\par \tab value_type& back() \{ return c.back(); \}
\par \tab const value_type& back() const \{ return c.back(); \}
\par \tab void push(const value_type& x) \{ c.push_back(x); \}
\par \tab void pop() \{ c.pop_front(); \}
\par \};
\par 
\par template <class Container>
\par bool operator==(const queue<Container>& x, const queue<Container>& y) \{
\par \tab return x.c == y.c;
\par \}
\par 
\par template <class Container>
\par bool operator<(const queue<Container>& x, const queue<Container>& y) \{
\par \tab return x.c < y.c;
\par \}
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285596}11.1.3 Priority queue}{\f9\fs20\cf1 {\*\bkmkend _Toc330285596}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
Any sequence with random access iterator and supporting operations front, push_back and pop_back can be used to instantiate priority_queue. In particular, vector and deque can be used.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class Container, class Compare = less<Container::value_type> >
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 class priority_queue \{
\par public:
\par \tab typedef Container::value_type value_type;
\par \tab typedef Container::size_type size_type;
\par protected:
\par \tab Container c;
\par \tab Compare comp;
\par public:
\par \tab priority_queue(const Compare& x = Compare()) : c(), comp(x) \{\}
\par \tab template <class InputIterator>
\par \tab priority_queue(InputIterator first, InputIterator last, 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab \tab const Compare& x = Compare()) : c(first, last), comp(x) \{
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab make_heap(c.begin(), c.end(), comp);
\par \tab \}
\par \tab bool empty() const \{ return c.empty(); \}
\par \tab size_type size() const \{ return c.size(); \}
\par \tab const value_type& top() const \{ return c.front(); \}
\par \tab void push(const value_type& x) \{ 
\par \tab \tab c.push_back(x);\tab \tab 
\par \tab \tab push_heap(c.begin(), c.end(), comp);
\par \tab \}
\par \tab void pop() \{
\par \tab \tab pop_heap(c.begin(), c.end(), comp);
\par \tab \tab c.pop_back();
\par \tab \}
\par \};
\par 
\par // no equality is provided
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285597}11.2 Iterator adaptors}{\f9\fs22\cf1 {\*\bkmkend _Toc330285597}
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285598}11.2.1 Reverse iterators}{\f9\fs20\cf1 {\*\bkmkend _Toc330285598}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 Bidirectional and random access iterators have corresponding reverse iterator adaptors that iterate through the data structure in the oppo
site direction. They have the same signatures as the corresponding iterators. The fundamental relation between a reverse iterator and its corresponding iterator i is established by the identity
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 &*(reverse_iterator(i)) == &*(i - 1).
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 This mapping is dictated by the fact that while there is always a pointer past the end of an array, there might not be a valid pointer before the beginning of an array.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class BidirectionalIterator, class T, class Reference = T&,
\par \tab class Distance = ptrdiff_t>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 class reverse_bidirectional_iterator 
\par \tab : public bidirectional_iterator<T, Distance> \{
\par \tab typedef reverse_bidirectional_iterator<BidirectionalIterator, T,
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab \tab \tab \tab \tab \tab Reference, \tab Distance> self;
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab friend bool operator==(const self& x, const self& y);
\par protected:
\par \tab BidirectionalIterator current;
\par public:
\par \tab reverse_bidirectional_iterator() \{\}
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab reverse_bidirectional_iterator(BidirectionalIterator x) : current(x) \{\}
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab BidirectionalIterator base() \{ return current; \}
\par \tab Reference operator*() const \{
\par \tab \tab BidirectionalIterator tmp = current;
\par \tab \tab return *--tmp;
\par \tab \}
\par \tab self& operator++() \{
\par \tab \tab --current;
\par \tab \tab return *this;
\par \tab \}
\par \tab self operator++(int) \{
\par \tab \tab self tmp = *this;
\par \tab \tab --current;
\par \tab \tab return tmp;
\par \tab \}
\par \tab self& operator--() \{
\par \tab \tab ++current;
\par \tab \tab return *this;
\par \tab \}
\par \tab self operator--(int) \{
\par \tab \tab self tmp = *this;
\par \tab \tab ++current;
\par \tab \tab return tmp;
\par \tab \}
\par \};
\par 
\par template <class BidirectionalIterator, class T, class Reference, class Distance>
\par inline bool operator==(
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab const reverse_bidirectional_iterator<BidirectionalIterator, T,
\par \tab \tab \tab \tab \tab \tab \tab \tab Reference, Distance>& x, 
\par \tab \tab const reverse_bidirectional_iterator<BidirectionalIterator, T,
\par \tab \tab \tab \tab \tab \tab \tab \tab Reference, Distance>& y) \{
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab return x.current == y.current;
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \}
\par 
\par template <class RandomAccessIterator, class T, class Reference = T&,
\par \tab class Distance = ptrdiff_t>
\par class reverse_iterator : public random_access_iterator<T, Distance> \{
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab typedef reverse_iterator<RandomAccessIterator, T, Reference, Distance>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab self;
\par \tab friend bool operator==(const self& x, const self& y);
\par \tab friend bool operator<(const self& x, const self& y);
\par \tab friend Distance operator-(const self& x, const self& y);
\par \tab friend self operator+(Distance n, const self& x);
\par protected:
\par \tab RandomAccessIterator current;
\par public:
\par \tab reverse_iterator() \{\}
\par \tab reverse_iterator(RandomAccessIterator x) : current(x) \{\}
\par \tab RandomAccessIterator base() \{ return current; \}
\par \tab Reference operator*() const \{
\par \tab \tab RandomAccessIterator tmp = current;
\par \tab \tab return *--tmp;
\par \tab \}
\par \tab self& operator++() \{
\par \tab \tab --current;
\par \tab \tab return *this;
\par \tab \}
\par \tab self operator++(int) \{
\par \tab \tab self tmp = *this;
\par \tab \tab --current;
\par \tab \tab return tmp;
\par \tab \}
\par \tab self& operator--() \{
\par \tab \tab ++current;
\par \tab \tab return *this;
\par \tab \}
\par \tab self operator--(int) \{
\par \tab \tab self tmp = *this;
\par \tab \tab ++current;
\par \tab \tab return tmp;
\par \tab \}
\par \tab self operator+(Distance n) \tab const \{
\par \tab \tab return self(current - n);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \}
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab self& \tab operator+=(Distance n) \{
\par \tab \tab current -= n;
\par \tab \tab return *this;
\par \tab \}
\par \tab self operator-(Distance n) const \{
\par \tab \tab return self(current + n);
\par \tab \}
\par \tab self& operator-=(Distance n) \{
\par \tab \tab current += n;
\par \tab \tab return *this;
\par \tab \}
\par \tab Reference operator[](Distance n) \{ return *(*this + n); \}
\par \};
\par 
\par template <class RandomAccessIterator, class T, class Reference, class Distance>
\par inline bool operator==(
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab const reverse_iterator<RandomAccessIterator, \tab \tab \tab \tab \tab \tab T, Reference, Distance>& x, 
\par \tab const reverse_iterator<RandomAccessIterator, T, Reference, Distance>& y) \{
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab return x.current == y.current;
\par \}
\par 
\par template <class RandomAccessIterator, class T, class Reference, class Distance>
\par inline bool operator<(
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab const reverse_iterator<RandomAccessIterator, T, Reference, Distance>& x, 
\par \tab const reverse_iterator<RandomAccessIterator, T, Reference, Distance>& y) \{
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab return y.current < x.current;
\par \}
\par 
\par template <class RandomAccessIterator, class T, class Reference, class Distance>
\par inline Distance operator-(
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab const reverse_iterator<RandomAccessIterator, T, Reference, Distance>& x, 
\par \tab const reverse_iterator<RandomAccessIterator, T, Reference, Distance>& y) \{
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab return y.current - x.current;
\par \}
\par 
\par template <class RandomAccessIterator, class T, class Reference, class Distance>
\par inline reverse_iterator<RandomAccessIterator, T, Reference, Distance> operator+(
\par \tab Distance n, 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab const reverse_iterator<RandomAccessIterator, T, Reference, Distance>& x) \{
\par \tab return reverse_iterator<RandomAccessIterator, T, Reference, \tab \tab \tab \tab \tab Distance>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab (x.current - n);
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \}
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285599}11.2.2 Insert iterators}{\f9\fs20\cf1 {\*\bkmkend _Toc330285599}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
To make it possible to deal with insertion in the same way as writing into an array, a special kind of iterator adaptors, called insert iterators, are provided in the library. With regular iterator classes,
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 while (first != last) *result++ = *first++;
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 causes a range [first, last) to be copied into a range starting with result. The same code with result being an insert iterator will insert c
orresponding elements into the container. This device allows all of the copying algorithms in the library to work in the insert mode instead of the regular overwrite mode. 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
An insert iterator is constructed from a container and possibly one of its iterators pointing to where insertion takes place if it is neither at the beginning nor at the end of the container. Insert iterators satisfy the requirements of output iterators. 
operator* returns the insert iterator itself. The assignment operator=(const T& x) i
s defined on insert iterators to allow writing into them, it inserts x right before where the insert iterator is pointing. In other words, an insert iterator is like a cursor pointing into the container where the insertion takes place. back_insert_iterato
r inserts elements at the end of a container, front_insert_iterator inserts elements at the beginning of a container, and insert_iterator inserts elements where the iterator points to in a container. back_inserter, front_inserter, and inserter are three f
unctions making the insert iterators out of a container.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class Container>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 class back_insert_iterator : public output_iterator \{
\par protected:
\par \tab Container& container;
\par public:
\par \tab back_insert_iterator(Container& x) : container(x) \{\}
\par \tab back_insert_iterator<Container>& 
\par \tab operator=(\tab const Container::value_type& value) \{
\par \tab \tab container.push_back(value);
\par \tab \tab return *this;
\par \tab \}
\par \tab back_insert_iterator<Container>& operator*() \{ return *this; \}
\par \tab back_insert_iterator<Container>& operator++() \{ return *this; \}
\par \tab back_insert_iterator<Container>& operator++(int) \{ return *this; \}
\par \};
\par 
\par template <class Container>
\par back_insert_iterator<Container> back_inserter(Container& x) \{
\par \tab return back_insert_iterator<Container>(x);
\par \}
\par 
\par template <class Container>
\par class front_insert_iterator : public output_iterator \{
\par protected:
\par \tab Container& container;
\par public:
\par \tab front_insert_iterator(Container& x) : container(x) \{\}
\par \tab front_insert_iterator<Container>&
\par \tab operator=(const Container::value_type& value) \{
\par \tab \tab container.push_front(value);
\par \tab \tab return *this;
\par \tab \}
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab front_insert_iterator<Container>& operator*() \{ return *this; \}
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab front_insert_iterator<Container>& operator++() \{ return *this; \}
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab front_insert_iterator<Container>& operator++(int) \{ return *this; \}
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \};
\par 
\par template <class Container>
\par front_insert_iterator<Container> front_inserter(Container& x) \{
\par \tab return front_insert_iterator<Container>(x);
\par \}
\par 
\par template <class Container>
\par class insert_iterator : public output_iterator \{
\par protected:
\par \tab Container& container;
\par \tab Container::iterator iter;
\par public:
\par \tab insert_iterator(Container& x, Container::iterator i)
\par \tab \tab : container(x), iter(i) \{\}
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab insert_iterator<Container>& \tab operator=(const Container::value_type& value) \{
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab iter = container.insert(iter, value);
\par \tab \tab ++iter;
\par \tab \tab return *this;
\par \tab \}
\par \tab insert_iterator<Container>& operator*() \{ return *this; \}
\par \tab insert_iterator<Container>& operator++() \{ return *this; \}
\par \tab insert_iterator<Container>& operator++(int) \{ return *this; \}
\par \};
\par 
\par template <class Container, class Iterator>
\par insert_iterator<Container> inserter(Container& x, Iterator i) \{
\par \tab return insert_iterator<Container>(x, Container::iterator(i));
\par \}
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285600}11.2.3 Raw storage iterator}{\f9\fs20\cf1 {\*\bkmkend _Toc330285600}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
raw_storage_iterator is provided to enable algorithms to store the results into uninitialized memory. The formal template parameter OutputIterator is required to have construct(OutputIterator, const T&) defined.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class OutputIterator, class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 class raw_storage_iterator : public output_iterator \{
\par protected:
\par \tab OutputIterator iter;
\par public:
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab raw_storage_iterator(OutputIterator x) : iter(x) \{\}
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab raw_storage_iterator<OutputIterator, T>& operator*() \{ return *this; \}
\par \tab raw_storage_iterator<OutputIterator, T>& operator=(const T& element) \{
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab construct(iter, element);
\par \tab \tab return *this;
\par \tab \}        
\par \tab raw_storage_iterator<OutputIterator, T>& operator++() \{
\par \tab \tab ++iter;
\par \tab \tab return *this;
\par \tab \}
\par \tab raw_storage_iterator<OutputIterator, T> operator++(int) \{
\par \tab \tab raw_storage_iterator<OutputIterator, T> tmp = *this;
\par \tab \tab ++iter;
\par \tab \tab return tmp;
\par \tab \}
\par \};
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285601}11.3 Function adaptors}{\f9\fs22\cf1 {\*\bkmkend _Toc330285601}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 Function adaptors work only with function object classes with argument types and result type defined. 
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285602}11.3.1 Negators}{\f9\fs20\cf1 {\*\bkmkend _Toc330285602}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 Negators not1 and not2 take a unary and a binary predicate correspondingly and return their complements.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class Predicate>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 class unary_negate : public unary_function<Predicate::argument_type, bool> \{
\par protected:
\par \tab Predicate pred;
\par public:
\par \tab unary_negate(const Predicate& x) : pred(x) \{\}
\par \tab bool operator()(const argument_type& x) const \{ return !pred(x); \}
\par \};
\par 
\par template <class Predicate>
\par unary_negate<Predicate> not1(const Predicate& pred) \{
\par \tab return unary_negate<Predicate>(pred);
\par \}
\par 
\par template <class Predicate> 
\par class binary_negate : public binary_function<Predicate::first_argument_type,
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab \tab \tab \tab \tab Predicate::second_argument_type, bool> \{
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 protected:
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab Predicate pred;
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 public:
\par \tab binary_negate(const Predicate& x) : pred(x) \{\}
\par \tab bool operator()(const first_argument_type& x, 
\par \tab \tab \tab  const second_argument_type& y) const \{
\par \tab \tab return !pred(x, y); 
\par \tab \}
\par \};
\par 
\par template <class Predicate>
\par binary_negate<Predicate> not2(const Predicate& pred) \{
\par \tab return binary_negate<Predicate>(pred);
\par \}
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285603}11.3.2 Binders}{\f9\fs20\cf1 {\*\bkmkend _Toc330285603}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 Binders bind1st an
d bind2nd take a function object f of two arguments and a value x and return a function object of one argument constructed out of f with the first or second argument correspondingly bound to x.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class Operation> 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 class binder1st : public unary_function<\tab \tab \tab \tab \tab Operation::second_argument_type,
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab \tab \tab \tab \tab Operation::result_type> \{
\par protected:
\par \tab Operation op;
\par \tab Operation::first_argument_type value;
\par public:
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab binder1st(const Operation& x, const Operation::first_argument_type& y)\tab 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab : op(x), value(y) \{\}
\par \tab result_type operator()(const argument_type& x) const \{
\par \tab \tab return op(value, x); 
\par \tab \}
\par \};
\par 
\par template <class Operation, class T>
\par binder1st<Operation> bind1st(const Operation& op, \tab \tab const T& x) \{
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab return binder1st<Operation>(op, Operation::first_argument_type(x));
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \}
\par 
\par template <class Operation> 
\par class binder2nd : public unary_function<Operation::first_argument_type,
\par \tab \tab \tab \tab \tab \tab Operation::result_type> \{
\par protected:
\par \tab Operation op;
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab Operation::second_argument_type value;
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 public:
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab binder2nd(const Operation& x, const Operation::second_argument_type& y) 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab \tab : op(x), value(y) \{\}
\par \tab result_type operator()(const argument_type& x) const \{
\par \tab \tab return op(x, value); 
\par \tab \}
\par \};
\par 
\par template <class Operation, class T>
\par binder2nd<Operation> bind2nd(const Operation& op, \tab \tab const T& x) \{
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab return binder2nd<Operation>(op, Operation::second_argument_type(x));
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
For example, find_if(v.begin(), v.end(), bind2nd(greater<int>(), 5)) finds the first integer in vector v greater than 5; find_if(v.begin(), v.end(), bind1st(greater<int>(), 5)) finds the first integer in v less than 5.
\par }\pard\plain \s40\ri-548\sb160\sl260\slmult0\nowidctlpar \f8 {\i\f9\fs20\cf1 {\*\bkmkstart _Toc330285604}11.3.3 Adaptors for pointers to functions{\*\bkmkend _Toc330285604} }{\f9\fs20\cf1 
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 To allow pointers to (unary and binary) functions to work with function adaptors the library provides:
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class Arg, class Result>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 class pointer_to_unary_function : public unary_function<Arg, Result> \{
\par protected:
\par \tab Result (*ptr)(Arg);
\par public:
\par \tab pointer_to_unary_function(Result (*x)(Arg)) \tab \tab : ptr(x) \{\}
\par \tab Result operator()(Arg x) const \{ return ptr(x); \}
\par \};
\par 
\par template <class Arg, class Result>
\par pointer_to_unary_function<Arg, Result> ptr_fun(Result (*x)(Arg)) \{
\par \tab return pointer_to_unary_function<Arg, Result>(x);
\par \}
\par 
\par template <class Arg1, class Arg2, class Result>
\par class pointer_to_binary_function : public binary_function<Arg1, Arg2, Result> \{
\par protected:
\par \tab Result (*ptr)(Arg1, Arg2);
\par public:
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab pointer_to_binary_function(Result (*x)(Arg1, Arg2)) \tab \tab : ptr(x) \{\}
\par \tab Result operator()(Arg1 x, Arg2 y) const \{ \tab \tab return ptr(x, y); \}
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \};
\par 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 template <class Arg1, class Arg2, class Result>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 pointer_to_binary_function<Arg1, Arg2, Result> 
\par ptr_fun(Result (*x)(Arg1, Arg2)) \{
\par \tab return pointer_to_binary_function<Arg1, Arg2, Result>(x);
\par \}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 For example, replace_if(v.begin(), v.end(), not1(bind2nd(ptr_fun(strcmp), \rdblquote C\rdblquote )), \rdblquote C++\rdblquote ) replaces all the \rdblquote C\rdblquote  with 
\rdblquote C++\rdblquote  in sequence v.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 Compilation systems that have multiple pointer to function types have to provide additional ptr_fun template functions. 
\par }\pard\plain \s34\ri-548\sb320\sl280\slmult0\nowidctlpar \f8 {\b\f9\cf1 {\*\bkmkstart _Toc330285605}12  Memory Handling}{\f9\cf1 {\*\bkmkend _Toc330285605}
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285606}12.1 Primitives}{\f9\fs22\cf1 {\*\bkmkend _Toc330285606}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 To obtain a typed pointer to an uninitialized memory buffer of a given size the following function is defined:
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 inline T* allocate(ptrdiff_t n, T*); // n >= 0
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 The size (in bytes) of the allocated buffer is no less than n*sizeof(T). 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 For every memory model there is a corresponding allocate template function defined with the first argument type being the distance type of the pointers in the memory model.
\par For example, if a compilation system supports __huge pointers with the distance type being long long, the following template function is provided:
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 inline T __huge* allocate(long long n, T __huge *);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 Also, the following functions are provided:
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 inline void deallocate(T* buffer);
\par 
\par template <class T1, class T2>
\par inline void construct(T1* p, const T2& value) \{
\par \tab new (p) T1(value);
\par \}
\par 
\par template <class T>
\par inline void destroy(T* pointer) \{
\par \tab pointer->~T();
\par \}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
deallocate frees the buffer allocated by allocate. For every memory model there are corresponding deallocate, construct and destroy template functions defined with the first argument type being the pointer type of the memory model.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 pair<T*, ptrdiff_t> get_temporary_buffer(ptrdiff_t n, T*);
\par 
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 template <class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 void return_temporary_buffer(T* p);
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 
get_temporary_buffer finds the largest buffer not greater than n*sizeof(T), and returns a pair consisting of the address and the capacity (in the units of sizeof(T)) of the buffer. return_temporary_buffer returns the buffer allocated by get_temporary_buff
er.
\par }\pard\plain \s37\ri-548\sb200\sl260\slmult0\nowidctlpar \f8 {\b\f9\fs22\cf1 {\*\bkmkstart _Toc330285607}12.2 Specialized algorithms}{\f9\fs22\cf1 {\*\bkmkend _Toc330285607}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 All the iterators that are used as formal template parameters in the following algorithms are required to have construct(ForwardIterator, const T&) defined.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
\par }\pard\plain \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar \f8 {\f3\fs18\cf1 template <class ForwardIterator>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 void destroy(ForwardIterator first, ForwardIterator last) \{
\par \tab while (first != last) destroy(first++);
\par \}
\par 
\par template <class InputIterator, class ForwardIterator>
\par ForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
\par \tab \tab \tab \tab    ForwardIterator result) \{
\par \tab while (first != last) construct(result++, *first++);
\par \tab return result;
\par \}
\par 
\par template <class ForwardIterator, class T>
\par void uninitialized_fill(ForwardIterator first, ForwardIterator last, 
\par \tab \tab \tab const T& x) \{
\par \tab while (first != last) construct(first++, x);
\par \}
\par 
\par template <class ForwardIterator, class Size, class T>
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T& x) \{
\par }\pard \s32\fi-1440\li2160\ri-548\sl280\slmult0\nowidctlpar {\f3\fs18\cf1 \tab while (n--) construct(first++, x);
\par \tab return first;
\par \}
\par }\pard\plain \s34\ri-548\sb320\sl280\slmult0\nowidctlpar \f8 {\b\f9\cf1 {\*\bkmkstart _Toc330285608}13  Acknowledgments}{\f9\cf1 {\*\bkmkend _Toc330285608}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 The following people contributed to the design of STL:
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 Pete Becker, David Jacobson, Mehdi Jazayeri, Tom Keffer, Andy Koenig, Dave Musser, Nathan Myers, Larry Podmolik, Bob Shaw, Carl Staelin, Bjarne Stroustrup, Mark Terribile, Parthasarathy 
Tirumalai, Mike Vilot, John Wilkes. 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
The present library is a descendant of several earlier libraries (in Scheme, Ada, and C++) which were designed jointly with Dave Musser. He contributed to all the aspects of the STL work: design of the overall structure, semantic requirements, algorithm d
esign, complexity analysis and performance measurements.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 Andy Koenig is responsible for explaining to us that C++ has an underlying abstract machine and that the generic library should fit this machine. He also convinced
 us that we should attempt to turn our work into a C++ standard proposal. 
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 
During the writing of the proposal Bjarne Stroustrup has been a constant supporter and has been giving us a lot of technical advice especially on the language dependent parts of the library.
\par Andy and Bjarne have answered literally hundreds of \ldblquote urgent\rdblquote  messages and phone calls of the form: \ldblquote Could we do this?\rdblquote  
\par Dan Fishman and Mary Loomis created the environment where we were able to concentrate on the design without any distractions.
\par Bill Worley is responsible for starting this project and supporting it throughout his tenure as our lab director.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 Rick Amerson and Dmitry Lenkov have given us advice and support.
\par }\pard\plain \s34\ri-548\sb320\sl280\slmult0\nowidctlpar \f8 {\b\f9\cf1 {\*\bkmkstart _Toc330285609}14  Bibliography}{\f9\cf1 {\*\bkmkend _Toc330285609}
\par }\pard\plain \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar \f8 {\f18\fs20\cf1 M. Ellis and B. Stroustrup, The Annotated C++ Reference Manual, Addison-Wesley, Massachusetts, 1990.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 D. Kapur, D. R. Musser, and A. A. Stepanov, \ldblquote Tecton, A Language for Manipulating Generic Objects,\rdblquote 
 Proc. of Workshop on Program Specification, Aarhus, Denmark, August 1981, Lecture Notes in Computer Science, Springer-Verlag, vol. 134, 1982.
\par D. Kapur, D. R. Musser, and A. A. Stepanov, \ldblquote Operators and Algebraic Structures,\rdblquote  Proc. of the Conference on Functional Programming Languages and Computer Architecture, Portsmouth, New Hampshire, October 1981.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 A. Kershenbaum, D. R. Musser, and A. A. Stepanov, \ldblquote Higher Order Imperative Programming,\rdblquote  Technical Report 88-10, Rensselaer Polytechnic Institute, April 1988.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 A. Koenig, \ldblquote Associative arrays in C++,\rdblquote  Proc. USENIX Conference, San Francisco, CA, June 1988.
\par A. Koenig, \ldblquote Applicators, Manipulators, and Function Objects,\rdblquote  C++ Journal, vol. 1, #1, Summer 1990.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 D. R. Musser and A. A. Stepanov, \ldblquote A Library of Generic Algorithms in Ada,\rdblquote  Proc. of 1987 ACM SIGAda International Conference, Boston, December, 1987.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 D. R. Musser and A. A. Stepanov, \ldblquote Generic Programming,\rdblquote  invited paper, in P. Gianni, Ed., ISSAC \lquote 
88 Symbolic and Algebraic Computation Proceedings, Lecture Notes in Computer Science, Springer-Verlag, vol. 358, 1989.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 D. R. Musser and A. A. Stepanov, Ada Generic Library, Springer-Verlag, 1989.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 D. R. Musser and A. A. Stepanov, \ldblquote Algorithm-Oriented Generic Libraries,\rdblquote  Software Practice and Experience, vol. 24(7), July 1994.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 M. Stahl and U. Steinm\'fcller, \ldblquote Generic Dynamic Arrays,\rdblquote  The C++ Report, October 1993.
\par J. E. Shopiro, \ldblquote Strings and Lists for C++,\rdblquote  AT&T Bell Labs Internal Technical Memorandum, July 1985.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 A. A. Stepanov and M. Lee, \ldblquote The Standard Template Library,\rdblquote  Technical Report HPL-94-34, Hewlett-Packard Laboratories, April 1994.
\par }\pard \s17\qj\ri-548\sb140\sl280\slmult0\nowidctlpar {\f18\fs20\cf1 B. Stroustrup, The Design and Evolution of C++, Addison-Wesley, Massachusetts, 1994.
\par }\pard\plain \qc\ri-548\sl280\slmult0\nowidctlpar \f8 {\b\cf1 Table 1: Relations among iterator categories
\par }\pard \qc\ri-548\sl280\slmult0\nowidctlpar {\cf1 
\par }\trowd \trqc \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \cellx3240\clbrdrt\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \cellx4248\clbrdrt\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \cellx5688\clbrdrt\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 
\cellx6696\clbrdrt\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \cellx7704\clbrdrt\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \cellx8712\clbrdrt\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx9576 \pard\plain \s21\qc\sl280\slmult0\nowidctlpar\intbl 
\f8 {\fs20\cf1 Random access\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 
\par \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 Bidirectional\cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 
\par \cell Forward\cell 
\par \cell }\pard \s21\qc\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 Input
\par 
\par }\pard \s21\qj\sl280\slmult0\nowidctlpar\intbl {\fs20\cf1 Output\cell }\pard\plain \widctlpar\intbl \f8 {\fs20\cf1 \row }\pard \qj\ri-548\sl280\slmult0\nowidctlpar {\fs20\cf1 
\par }}